{
    "_G": {
        "body": "_G(${0:...})",
        "description": "_G",
        "prefix": "_G"
    },
    "_VERSION": {
        "body": "_VERSION(${0:...})",
        "description": "_VERSION",
        "prefix": "_VERSION"
    },
    "_log(level, tag, ...) (local函数 无法被外部调用)": {
        "body": "_log(${1:level},${2: tag},${3: ...) (local函数 无法被外部调用})",
        "description": "内部函数，支持不同级别的log打印及判断\r\n返回值：\r\nnil\r\n例子：\r\n_log(LOGLEVEL_TRACE,tag, 'log content')\r\n_log(LOGLEVEL_DEBUG,tag, 'log content')\r\n",
        "prefix": "_log(level, tag, ...) (local函数 无法被外部调用)"
    },
    "aLiPay.close(cbFnc)": {
        "body": "aLiPay.close(${1:cbFnc})",
        "description": "关闭aLiPay（注意：关闭aLiPay之后，只能重启才能再次自动开启）\r\n返回值：\r\nnil\r\n例子：\r\naLiPay.close(cbFnc)\r\n",
        "prefix": "aLiPay.close(cbFnc)"
    },
    "aLiPay.getBiztid()": {
        "body": "aLiPay.getBiztid()",
        "description": "获取设备的biztid(注意，必须在connectCb之后才能获取成功)\r\n返回值：\r\nstring\r\n例子：\r\naLiPay.getBiztid()\r\n",
        "prefix": "aLiPay.getBiztid()"
    },
    "aLiPay.on(evt, cbFnc)": {
        "body": "aLiPay.on(${1:evt},${2: cbFnc})",
        "description": "注册事件的处理函数\r\n返回值：\r\nnil\r\n例子：\r\naLiPay.on(\"connect\",connectCbFnc)\r\n",
        "prefix": "aLiPay.on(evt, cbFnc)"
    },
    "aLiPay.sendActData(broadcastCnt, scanCnt, cbFnc)": {
        "body": "aLiPay.sendActData(${1:broadcastCnt},${2: scanCnt},${3: cbFnc})",
        "description": "缓存行为数据（注意：缓存成功后，并不是立即上报，而是缓存到一定条数之后才会上报）\r\n返回值：\r\nnil\r\n例子：\r\naLiPay.sendActData(1,2,cbFnc)\r\n",
        "prefix": "aLiPay.sendActData(broadcastCnt, scanCnt, cbFnc)"
    },
    "aLiPay.sendProductInfoData(humanVerify, cbFnc)": {
        "body": "aLiPay.sendProductInfoData(${1:humanVerify},${2: cbFnc})",
        "description": "缓存产品规格信息数据（注意：缓存成功后，并不是立即上报，而是缓存到一定条数之后才会上报）\r\n返回值：\r\nnil\r\n例子：\r\naLiPay.sendProductInfoData(0x01,cbFnc)\r\naLiPay.sendProductInfoData(0x01+0x02+0x04,cbFnc)\r\n",
        "prefix": "aLiPay.sendProductInfoData(humanVerify, cbFnc)"
    },
    "aLiPay.sendTransactionData(businessNo, qrcode, amount, timeConsuming, tradeResult, cbFnc)": {
        "body": "aLiPay.sendTransactionData(${1:businessNo},${2: qrcode},${3: amount},${4: timeConsuming},${5: tradeResult},${6: cbFnc})",
        "description": "缓存交易信息数据（注意：缓存成功后，并不是立即上报，而是缓存到一定条数之后才会上报）\r\n返回值：\r\nnil\r\n例子：\r\naLiPay.sendTransactionData(\"88899998888\",\"98765\",1234,4,5,0,cbFnc)\r\n",
        "prefix": "aLiPay.sendTransactionData(businessNo, qrcode, amount, timeConsuming, tradeResult, cbFnc)"
    },
    "aLiPay.setup(deviceSupplier, merchantUser, itemId, productKey, getTerminalIdFnc)": {
        "body": "aLiPay.setup(${1:deviceSupplier},${2: merchantUser},${3: itemId},${4: productKey},${5: getTerminalIdFnc})",
        "description": "配置支付宝产品参数\r\n返回值：\r\nnil\r\n例子：\r\naLiPay.setup(\"201903131900940927\",\"201903131900940927\",\"2019031301993185\",\"SMART_RETAIL_MODULE\",getTerminalId)\r\n",
        "prefix": "aLiPay.setup(deviceSupplier, merchantUser, itemId, productKey, getTerminalIdFnc)"
    },
    "aLiPay.sign(mode, data, amount, cbFnc)": {
        "body": "aLiPay.sign(${1:mode},${2: data},${3: amount},${4: cbFnc})",
        "description": "对待交易数据进行加签\r\n返回值：\r\nnil\r\n例子：\r\naLiPay.sign(1,\"sign_data\",\"100\",cbFnc)\r\n",
        "prefix": "aLiPay.sign(mode, data, amount, cbFnc)"
    },
    "aLiYun.on(evt, cbFnc)": {
        "body": "aLiYun.on(${1:evt},${2: cbFnc})",
        "description": "注册事件的处理函数\r\n返回值：\r\nnil\r\n例子：\r\naLiYun.on(\"b0FMK1Ga5cp\",nil,getDeviceNameFnc,getDeviceSecretFnc)\r\n",
        "prefix": "aLiYun.on(evt, cbFnc)"
    },
    "aLiYun.publish(topic, payload, qos, cbFnc, cbPara)": {
        "body": "aLiYun.publish(${1:topic},${2: payload},${3: qos},${4: cbFnc},${5: cbPara})",
        "description": "发布一条消息\r\n返回值：\r\nnil\r\n例子：\r\naLiYun.publish(\"/b0FMK1Ga5cp/862991234567890/update\",\"test\",0)\r\naLiYun.publish(\"/b0FMK1Ga5cp/862991234567890/update\",\"test\",1,cbFnc,\"cbFncPara\")\r\n",
        "prefix": "aLiYun.publish(topic, payload, qos, cbFnc, cbPara)"
    },
    "aLiYun.setErrHandle(cbFnc, tmout)": {
        "body": "aLiYun.setErrHandle(${1:cbFnc},${2: tmout})",
        "description": "设置阿里云task连续一段时间工作异常的处理程序\r\n返回值：\r\nnil\r\n例子：\r\naLiYun.setErrHandle(function() sys.restart(\"ALIYUN_TASK_INACTIVE\") end, 300)\r\n",
        "prefix": "aLiYun.setErrHandle(cbFnc, tmout)"
    },
    "aLiYun.setMqtt(cleanSession, will, keepAlive)": {
        "body": "aLiYun.setMqtt(${1:cleanSession},${2: will},${3: keepAlive})",
        "description": "设置MQTT数据通道的参数\r\n返回值：\r\nnil\r\n例子：\r\naLiYun.setMqtt(0)\r\naLiYun.setMqtt(1,{qos=0,retain=1,topic=\"/willTopic\",payload=\"will payload\"})\r\naLiYun.setMqtt(1,{qos=0,retain=1,topic=\"/willTopic\",payload=\"will payload\"},120)\r\n",
        "prefix": "aLiYun.setMqtt(cleanSession, will, keepAlive)"
    },
    "aLiYun.setup(productKey, productSecret, getDeviceNameFnc, getDeviceSecretFnc, setDeviceSecretFnc)": {
        "body": "aLiYun.setup(${1:productKey},${2: productSecret},${3: getDeviceNameFnc},${4: getDeviceSecretFnc},${5: setDeviceSecretFnc})",
        "description": "配置阿里云物联网套件的产品信息和设备信息\r\n返回值：\r\nnil\r\n例子：\r\naLiYun.setup(\"b0FMK1Ga5cp\",nil,getDeviceNameFnc,getDeviceSecretFnc)\r\naLiYun.setup(\"a1AoVqkCIbG\",\"7eCdPyR6fYPntFcM\",getDeviceNameFnc,getDeviceSecretFnc,setDeviceSecretFnc)\r\n",
        "prefix": "aLiYun.setup(productKey, productSecret, getDeviceNameFnc, getDeviceSecretFnc, setDeviceSecretFnc)"
    },
    "aLiYun.sleep()": {
        "body": "aLiYun.sleep()",
        "description": "断开阿里云物联网套件的连接，并且不再重连\r\n返回值：\r\nnil\r\n例子：\r\naLiYun.sleep()\r\n",
        "prefix": "aLiYun.sleep()"
    },
    "aLiYun.sleepStatus()": {
        "body": "aLiYun.sleepStatus()",
        "description": "查看打开阿里云物联网套件的是否允许连接状态\r\n返回值：\r\nbool 是否允许连接阿里云\r\n例子：\r\nlocal ar = aLiYun.sleepStatus()\r\n",
        "prefix": "aLiYun.sleepStatus()"
    },
    "aLiYun.subscribe(topic, qos)": {
        "body": "aLiYun.subscribe(${1:topic},${2: qos})",
        "description": "订阅主题\r\n返回值：\r\nnil\r\n例子：\r\naLiYun.subscribe(\"/b0FMK1Ga5cp/862991234567890/get\", 0)\r\naLiYun.subscribe({[\"/b0FMK1Ga5cp/862991234567890/get\"] = 0, [\"/b0FMK1Ga5cp/862991234567890/get\"] = 1})\r\n",
        "prefix": "aLiYun.subscribe(topic, qos)"
    },
    "aLiYun.wakeup()": {
        "body": "aLiYun.wakeup()",
        "description": "重新打开阿里云物联网套件的连接\r\n返回值：\r\nnil\r\n例子：\r\naLiYun.wakeup()\r\n",
        "prefix": "aLiYun.wakeup()"
    },
    "aLiYunOta.setCb(cbFnc)": {
        "body": "aLiYunOta.setCb(${1:cbFnc})",
        "description": "设置新固件下载后的回调函数\r\n返回值：\r\nnil\r\n例子：\r\naLiYunOta.setCb(cbFnc)\r\n",
        "prefix": "aLiYunOta.setCb(cbFnc)"
    },
    "aLiYunOta.setName(name)": {
        "body": "aLiYunOta.setName(${1:name})",
        "description": "设置新固件保存的文件名\r\n返回值：\r\nnil\r\n例子：\r\naLiYunOta.setName(\"MCU_FIRMWARE.bin\")\r\n",
        "prefix": "aLiYunOta.setName(name)"
    },
    "aLiYunOta.setVer(version)": {
        "body": "aLiYunOta.setVer(${1:version})",
        "description": "设置当前的固件版本号\r\n返回值：\r\nnil\r\n例子：\r\naLiYunOta.setVer(\"MCU_VERSION_1.0.0\")\r\n",
        "prefix": "aLiYunOta.setVer(version)"
    },
    "adc.colse()": {
        "body": "adc.colse()",
        "description": "关闭adc\r\n返回值：\r\n  无",
        "prefix": "adc.colse()"
    },
    "adc.open()": {
        "body": "adc.open()",
        "description": "打开对应ID的ADC通道\r\n返回值：\r\n1：成功打开adc通道\r\n0：其他\r\n例子：\r\n--adc id\r\nlocal ADC_ID = 0\r\n--打开adc\r\nadc.open(ADC_ID)\r\n",
        "prefix": "adc.open()"
    },
    "adc.read()": {
        "body": "adc.read()",
        "description": "读取原始测量数据和电压值，电压值单位为mv\r\n返回值：\r\nadcValue,原始数据ad值，无效值为0xFFFF。voltValue,电压值，单位为mv，无效值为0xFFFF\r\n例子：\r\n--adcval为number类型，表示adc的原始值，无效值为0xFFFF\r\n--voltval为number类型，表示转换后的电压值，单位为毫伏，无效值为0xFFFF；adc.read接口返回的voltval放大了3倍，所以需要除以3还原成原始电压\r\nlocal adcval,voltval = adc.read(ADC_ID)\r\n",
        "prefix": "adc.read()"
    },
    "apn.get_default_apn()": {
        "body": "apn.get_default_apn()",
        "description": "通过mcc和mnc获取到默认apn\r\n返回值：\r\napn,apn名字\r\nuser,用户名\r\npassword,密码",
        "prefix": "apn.get_default_apn()"
    },
    "assert": {
        "body": "assert(${1:v}${2:[, message]})",
        "description": "assert()",
        "prefix": "assert"
    },
    "audio.getMicVolume(vol)": {
        "body": "audio.getMicVolume(${1:vol})",
        "description": "获取麦克音量等级\r\n返回值：\r\nnumber vol，麦克音量等级\r\n例子：\r\naudio.getMicVolume()\r\n",
        "prefix": "audio.getMicVolume(vol)"
    },
    "audio.getVolume()": {
        "body": "audio.getVolume()",
        "description": "获取喇叭音量等级\r\n返回值：\r\nnumber vol，喇叭音量等级\r\n例子：\r\naudio.getVolume()\r\n",
        "prefix": "audio.getVolume()"
    },
    "audio.play(priority, type, path, vol, cbFnc, dup, dupInterval)": {
        "body": "audio.play(${1:priority},${2: type},${3: path},${4: vol},${5: cbFnc},${6: dup},${7: dupInterval})",
        "description": "播放音频\r\n返回值：\r\nresult，bool或者nil类型，同步调用成功返回true，否则返回false\r\n例子：\r\naudio.play(0,\"FILE\",\"/ldata/call.mp3\")\r\naudio.play(0,\"FILE\",\"/ldata/call.mp3\",7)\r\naudio.play(0,\"FILE\",\"/ldata/call.mp3\",7,cbFnc)\r\n-- 更多用法参考demo/audio/testAudio.lua\r\n",
        "prefix": "audio.play(priority, type, path, vol, cbFnc, dup, dupInterval)"
    },
    "audio.setMicVolume(vol)": {
        "body": "audio.setMicVolume(${1:vol})",
        "description": "设置麦克音量等级\r\n返回值：\r\nbool result，设置成功返回true,失败返回false\r\n例子：\r\naudio.setMicVolume(14)\r\n",
        "prefix": "audio.setMicVolume(vol)"
    },
    "audio.setStrategy(strategy)": {
        "body": "audio.setStrategy(${1:strategy})",
        "description": "设置优先级相同时的播放策略\r\n返回值：\r\nnil\r\n例子：\r\naudio.setStrategy(0)\r\naudio.setStrategy(1)\r\n",
        "prefix": "audio.setStrategy(strategy)"
    },
    "audio.setTTSSpeed(speed)": {
        "body": "audio.setTTSSpeed(${1:speed})",
        "description": "设置TTS朗读速度\r\n返回值：\r\nbool result，设置成功返回true，失败返回false\r\n例子：\r\naudio.setTTSSpeed(70)\r\n",
        "prefix": "audio.setTTSSpeed(speed)"
    },
    "audio.setVolume(vol)": {
        "body": "audio.setVolume(${1:vol})",
        "description": "设置喇叭音量等级\r\n返回值：\r\nbool result，设置成功返回true，失败返回false\r\n例子：\r\naudio.setVolume(7)\r\n",
        "prefix": "audio.setVolume(vol)"
    },
    "audio.stop(cbFnc)": {
        "body": "audio.stop(${1:cbFnc})",
        "description": "停止音频播放\r\n返回值：\r\nnil\r\n例子：\r\naudio.stop()\r\n",
        "prefix": "audio.stop(cbFnc)"
    },
    "audiocore.play()": {
        "body": "audiocore.play()",
        "description": "播放音乐\r\n返回值：\r\n  true:播放成功\r\nfalse:播放失败",
        "prefix": "audiocore.play()"
    },
    "audiocore.setchannel()": {
        "body": "audiocore.setchannel()",
        "description": "设置音频播放通道",
        "prefix": "audiocore.setchannel()"
    },
    "audiocore.setloopback()": {
        "body": "audiocore.setloopback()",
        "description": "设置通道指定的环回测试\r\n返回值：\r\n  1:成功\r\n0:其他",
        "prefix": "audiocore.setloopback()"
    },
    "audiocore.setmicvol()": {
        "body": "audiocore.setmicvol()",
        "description": "设置麦克风音量\r\n返回值：\r\n  1:成功\r\n0:其他",
        "prefix": "audiocore.setmicvol()"
    },
    "audiocore.setvol()": {
        "body": "audiocore.setvol()",
        "description": "设置音频播放音量大小\r\n返回值：\r\n  1:成功\r\n0:其他",
        "prefix": "audiocore.setvol()"
    },
    "audiocore.stop()": {
        "body": "audiocore.stop()",
        "description": "停掉正在播放的音频\r\n返回值：\r\n  无",
        "prefix": "audiocore.stop()"
    },
    "bit.arshift()": {
        "body": "bit.arshift()",
        "description": "算数右移\r\n返回值：\r\n  算术右移之后的结果\r\n例子：\r\nprint(bit.arshift(2,2))--算数右移，左边添加的数与符号有关，输出为0\r\n",
        "prefix": "bit.arshift()"
    },
    "bit.band()": {
        "body": "bit.band()",
        "description": "与运算，等价于Ｃ语言中的val1 & val2 & ... & valn\r\n返回值：\r\n  与运算之后的结果\r\n例子：\r\nprint(bit.band(1,1))--与,--输出1\r\n",
        "prefix": "bit.band()"
    },
    "bit.bit()": {
        "body": "bit.bit()",
        "description": "左移运算，等价于C语言中的1 << position\r\n返回值：\r\n  移位运算后的值\r\n例子：\r\nprint(bit.bit(2))--参数是位数，作用是1向左移动两位，打印出4\r\n",
        "prefix": "bit.bit()"
    },
    "bit.bnot()": {
        "body": "bit.bnot()",
        "description": "取反，等价于C语言中的~\r\n返回值：\r\n  取反之后的值\r\n例子：\r\nprint(bit.bnot(5))--按位取反，输出-6\r\n",
        "prefix": "bit.bnot()"
    },
    "bit.bor()": {
        "body": "bit.bor()",
        "description": "或运算，等价于C里面的val1 | val2 | ... | valn\r\n返回值：\r\n  或运算之后的结果\r\n例子：\r\nprint(bit.bor(1,2))--或，--输出3\r\n",
        "prefix": "bit.bor()"
    },
    "bit.bxor()": {
        "body": "bit.bxor()",
        "description": "异或运算，等价于C语言中的val1 ^ val2 ^ ... ^ valn\r\n返回值：\r\n  异或运算之后的结果\r\n例子：\r\nprint(bit.bxor(1,2))--异或,相同为0，不同为1\r\n",
        "prefix": "bit.bxor()"
    },
    "bit.clear()": {
        "body": "bit.clear()",
        "description": "置0\r\n返回值：\r\n  置0之后的值\r\n例子：\r\nprint(bit.clear(5,0,2)) --在相应的位置置0，打印0\r\n",
        "prefix": "bit.clear()"
    },
    "bit.isclear()": {
        "body": "bit.isclear()",
        "description": "测试位数是否被置0\r\n返回值：\r\n  true:该位被置0\r\nfalse:其他\r\n例子：\r\nprint(bit.isclear(5,0))--与上面的相反\r\nprint(bit.isclear(5,1))\r\nprint(bit.isclear(5,2))\r\nprint(bit.isclear(5,3))\r\n",
        "prefix": "bit.isclear()"
    },
    "bit.isset()": {
        "body": "bit.isset()",
        "description": "测试位数是否被置1\r\n返回值：\r\n  true:该位被置1\r\nfalse:其他\r\n例子：\r\nprint(bit.isset(5,0))--第一个参数是是测试数字，第二个是测试位置。从右向左数0到7。是1返回true，否则返回false，该返回true\r\nprint(bit.isset(5,1))--打印false\r\nprint(bit.isset(5,2))--打印true\r\nprint(bit.isset(5,3))--返回返回false\r\n",
        "prefix": "bit.isset()"
    },
    "bit.lshift()": {
        "body": "bit.lshift()",
        "description": "逻辑左移，等价于C语言中的value << shift\r\n返回值：\r\n  逻辑左移之后的结果\r\n例子：\r\nprint(bit.lshift(1,2))--逻辑左移，“100”，输出为4\r\n",
        "prefix": "bit.lshift()"
    },
    "bit.rshift()": {
        "body": "bit.rshift()",
        "description": "逻辑右移，等价于C语言中的value >> shift\r\n返回值：\r\n  逻辑右移之后的结果\r\n例子：\r\nprint(bit.rshift(4,2))--逻辑右移，“001”，输出为1\r\n",
        "prefix": "bit.rshift()"
    },
    "bit.set()": {
        "body": "bit.set()",
        "description": "置1\r\n返回值：\r\n  置1之后的值\r\n例子：\r\nprint(bit.set(0,0,1,2,3))--在相应的位数置1，打印15\r\n",
        "prefix": "bit.set()"
    },
    "cc.accept(num)": {
        "body": "cc.accept(${1:num})",
        "description": "接听电话\r\n返回值：\r\nnil\r\n例子：\r\ncc.accept('10086')\r\n",
        "prefix": "cc.accept(num)"
    },
    "cc.anyCallExist()": {
        "body": "cc.anyCallExist()",
        "description": "是否存在通话\r\n返回值：\r\nbool result 存在通话返回true，否则返回false\r\n例子：\r\nresult = cc.anyCallExist()\r\n",
        "prefix": "cc.anyCallExist()"
    },
    "cc.dial(num, delay)": {
        "body": "cc.dial(${1:num},${2: delay})",
        "description": "呼出电话\r\n返回值：\r\nbool result，true表示允许发送at命令拨号并且发送at，false表示不允许at命令拨号\r\n例子：\r\ncc.dial('10086')\r\n",
        "prefix": "cc.dial(num, delay)"
    },
    "cc.dtmfDetect(enable, sens)": {
        "body": "cc.dtmfDetect(${1:enable},${2: sens})",
        "description": "设置dtmf检测是否使能以及灵敏度\r\n返回值：\r\nnil\r\n例子：\r\ncc.dtmfDetect(true)\r\n",
        "prefix": "cc.dtmfDetect(enable, sens)"
    },
    "cc.getState(num)": {
        "body": "cc.getState(${1:num})",
        "description": "查询某个号码的通话状态\r\n返回值：\r\nnumber state 通话状态，状态值参考本模块Fields定义\r\n例子：\r\nstate = cc.getState('10086')\r\n",
        "prefix": "cc.getState(num)"
    },
    "cc.hangUp(num)": {
        "body": "cc.hangUp(${1:num})",
        "description": "挂断通话\r\n返回值：\r\nnil\r\n例子：\r\ncc.hangUp('10086')\r\n",
        "prefix": "cc.hangUp(num)"
    },
    "cc.sendDtmf(str, playtime, intvl)": {
        "body": "cc.sendDtmf(${1:str},${2: playtime},${3: intvl})",
        "description": "发送dtmf到对端\r\n返回值：\r\nnil\r\n例子：\r\ncc.sendDtmf(\"123\")\r\n",
        "prefix": "cc.sendDtmf(str, playtime, intvl)"
    },
    "cc.transVoice(data, loop, downLinkPlay)": {
        "body": "cc.transVoice(${1:data},${2: loop},${3: downLinkPlay})",
        "description": "通话中发送声音到对端,必须是12.2K AMR格式\r\n返回值：\r\nbool result true为成功，false为失败\r\n例子：\r\ncc.transVoice(\"#!AMR\\010\\060*********\")\r\ncc.transVoice(\"#!AMR\\010\\060*********\",true)\r\ncc.transVoice(\"#!AMR\\010\\060*********\",true,true)\r\n",
        "prefix": "cc.transVoice(data, loop, downLinkPlay)"
    },
    "collectgarbage": {
        "body": "collectgarbage(${1:[opt]}${2:[, arg]})",
        "description": "collectgarbage()",
        "prefix": "collectgarbage"
    },
    "common.bcdNumToNum(num)": {
        "body": "common.bcdNumToNum(${1:num})",
        "description": "BCD编码格式字符串 转化为 号码ASCII字符串(仅支持数字)\r\n返回值：\r\nstring data,转换后的字符串\r\n例子：\r\nlocal data = common.bcdNumToNum(common.fromHex(\"688121364265f7\")) --表示第1个字节是0x68，第2个字节为0x81，......\r\ndata is \"8618126324567\"\r\n",
        "prefix": "common.bcdNumToNum(num)"
    },
    "common.gb2312ToUcs2(gb2312s)": {
        "body": "common.gb2312ToUcs2(${1:gb2312s})",
        "description": "gb2312编码 转化为 unicode小端编码\r\n返回值：\r\nstring data,unicode小端编码数据\r\n例子：\r\nlocal data = common.gb2312ToUcs2(gb2312s)\r\n",
        "prefix": "common.gb2312ToUcs2(gb2312s)"
    },
    "common.gb2312ToUcs2be(gb2312s)": {
        "body": "common.gb2312ToUcs2be(${1:gb2312s})",
        "description": "gb2312编码 转化为 unicode大端编码\r\n返回值：\r\nstring data,unicode大端编码数据\r\n例子：\r\nlocal data = common.gb2312ToUcs2be(gb2312s)\r\n",
        "prefix": "common.gb2312ToUcs2be(gb2312s)"
    },
    "common.gb2312ToUtf8(gb2312s)": {
        "body": "common.gb2312ToUtf8(${1:gb2312s})",
        "description": "gb2312编码 转化为 utf8编码\r\n返回值：\r\nstring data,utf8编码数据\r\n例子：\r\nlocal data = common.gb2312ToUtf8(gb2312s)\r\n",
        "prefix": "common.gb2312ToUtf8(gb2312s)"
    },
    "common.nstrToUcs2Hex(inNum)": {
        "body": "common.nstrToUcs2Hex(${1:inNum})",
        "description": "ascii字符串 转化为 ascii字符串的unicode编码的16进制字符串(仅支持数字和+)\r\n返回值：\r\nstring data,转换后的字符串\r\n例子：\r\nlocal data = common.nstrToUcs2Hex(\"+1234\")\r\ndata is \"002B0031003200330034\"\r\n",
        "prefix": "common.nstrToUcs2Hex(inNum)"
    },
    "common.numToBcdNum(inStr, destLen)": {
        "body": "common.numToBcdNum(${1:inStr},${2: destLen})",
        "description": "ASCII字符串 转化为 BCD编码格式字符串(仅支持数字)\r\n返回值：\r\nstring data,转换后的字符串\r\n例子：\r\nlocal data = common.numToBcdNum(\"8618126324567\")\r\ndata is \"688121364265f7\" （表示第1个字节是0x68，第2个字节为0x81，......）\r\n",
        "prefix": "common.numToBcdNum(inStr, destLen)"
    },
    "common.timeZoneConvert(y, m, d, hh, mm, ss, srcTimeZone, dstTimeZone)": {
        "body": "common.timeZoneConvert(${1:y},${2: m},${3: d},${4: hh},${5: mm},${6: ss},${7: srcTimeZone},${8: dstTimeZone})",
        "description": "时区时间转换\r\n返回值：\r\ntable dstZoneTime,返回目的时区对应的时间，{year,month,day,hour,min,sec}\r\n例子：\r\nlocal dstZoneTime = common.timeZoneConvert(2018,1,1,18,00,00,0,8)\r\ndstZoneTime为{year=2018,month=1,day=2,hour=2,min=0,sec=0}\r\n",
        "prefix": "common.timeZoneConvert(y, m, d, hh, mm, ss, srcTimeZone, dstTimeZone)"
    },
    "common.ucs2ToAscii(inNum)": {
        "body": "common.ucs2ToAscii(${1:inNum})",
        "description": "ascii字符串的unicode编码的16进制字符串 转化为 ascii字符串\r\n返回值：\r\nstring data，转换后的字符串\r\n例子：\r\nlocal data = common.ucs2ToAscii(\"0031003200330034\")\r\ndata is \"1234\"\r\n",
        "prefix": "common.ucs2ToAscii(inNum)"
    },
    "common.ucs2ToGb2312(ucs2s)": {
        "body": "common.ucs2ToGb2312(${1:ucs2s})",
        "description": "unicode小端编码 转化为 gb2312编码\r\n返回值：\r\nstring data,gb2312编码数据\r\n例子：\r\nlocal data = common.ucs2ToGb2312(ucs2s)\r\n",
        "prefix": "common.ucs2ToGb2312(ucs2s)"
    },
    "common.ucs2ToUtf8(ucs2s)": {
        "body": "common.ucs2ToUtf8(${1:ucs2s})",
        "description": "unicode小端编码 转化为 utf8编码\r\n返回值：\r\nstring data,utf8编码数据\r\n例子：\r\ndata = common.ucs2ToUtf8(ucs2s)\r\n",
        "prefix": "common.ucs2ToUtf8(ucs2s)"
    },
    "common.ucs2beToGb2312(ucs2s)": {
        "body": "common.ucs2beToGb2312(${1:ucs2s})",
        "description": "unicode大端编码 转化为 gb2312编码\r\n返回值：\r\nstring data,gb2312编码数据\r\n例子：\r\ndata = common.ucs2beToGb2312(ucs2s)\r\n",
        "prefix": "common.ucs2beToGb2312(ucs2s)"
    },
    "common.ucs2beToUtf8(ucs2s)": {
        "body": "common.ucs2beToUtf8(${1:ucs2s})",
        "description": "unicode大端编码 转化为 utf8编码\r\n返回值：\r\nstring data,utf8编码数据\r\n例子：\r\ndata = common.ucs2beToUtf8(ucs2s)\r\n",
        "prefix": "common.ucs2beToUtf8(ucs2s)"
    },
    "common.utf8ToGb2312(utf8s)": {
        "body": "common.utf8ToGb2312(${1:utf8s})",
        "description": "utf8编码 转化为 gb2312编码\r\n返回值：\r\nstring data,gb2312编码数据\r\n例子：\r\nlocal data = common.utf8ToGb2312(utf8s)\r\n",
        "prefix": "common.utf8ToGb2312(utf8s)"
    },
    "common.utf8ToUcs2(utf8s)": {
        "body": "common.utf8ToUcs2(${1:utf8s})",
        "description": "utf8编码 转化为 unicode小端编码\r\n返回值：\r\nstring data,unicode小端编码数据\r\n例子：\r\nlocal data = common.utf8ToUcs2(utf8s)\r\n",
        "prefix": "common.utf8ToUcs2(utf8s)"
    },
    "common.utf8ToUcs2be(utf8s)": {
        "body": "common.utf8ToUcs2be(${1:utf8s})",
        "description": "utf8编码 转化为 unicode大端编码\r\n返回值：\r\nstring data,unicode大端编码数据\r\n例子：\r\nlocal data = common.utf8ToUcs2be(utf8s)\r\n",
        "prefix": "common.utf8ToUcs2be(utf8s)"
    },
    "console.setup(id, baudrate)": {
        "body": "console.setup(${1:id},${2: baudrate})",
        "description": "配置控制台使用的串口参数，创建控制台协程\r\n返回值：\r\nnil\r\n例子：\r\nconsole.setup(1, 115200)\r\n",
        "prefix": "console.setup(id, baudrate)"
    },
    "coroutine.create": {
        "body": "coroutine.create( ${1:function} )",
        "description": "coroutine.create",
        "prefix": "coroutine.create"
    },
    "coroutine.isyieldable": {
        "body": "coroutine.isyieldable( )",
        "description": "coroutine.isyieldable",
        "prefix": "coroutine.isyieldable"
    },
    "coroutine.resume": {
        "body": "coroutine.resume( ${1:co}${2:[, val1, ···]} )",
        "description": "coroutine.resume",
        "prefix": "coroutine.resume"
    },
    "coroutine.running": {
        "body": "coroutine.running( )",
        "description": "coroutine.running",
        "prefix": "coroutine.running"
    },
    "coroutine.status": {
        "body": "coroutine.status( ${1:co} )",
        "description": "coroutine.status",
        "prefix": "coroutine.status"
    },
    "coroutine.wrap": {
        "body": "coroutine.wrap( ${1:function} )",
        "description": "coroutine.wrap",
        "prefix": "coroutine.wrap"
    },
    "coroutine.yield": {
        "body": "coroutine.yield( ${1:...} )",
        "description": "coroutine.yield",
        "prefix": "coroutine.yield"
    },
    "crypto.aes_encrypt()": {
        "body": "crypto.aes_encrypt()",
        "description": "aes算法（参考http://tool.chacuo.net/cryptaes）\r\n返回值：\r\n  已加密的字符串\r\n例子：\r\n--下面示例为LuaTask的，如果需要LuaScript的，请参考LuaScript crypto demo\r\nlocal originStr = \"AES128 ECB ZeroPadding test\"\r\n--加密模式：ECB；填充方式：ZeroPadding；密钥：1234567890123456；密钥长度：128 bit\r\nlocal encodeStr = crypto.aes_encrypt(\"ECB\",\"ZERO\",originStr,\"1234567890123456\")\r\nprint(originStr,\"encrypt\",string.toHex(encodeStr))\r\nlog.info(\"testCrypto.decrypt\",crypto.aes_decrypt(\"ECB\",\"ZERO\",encodeStr,\"1234567890123456\"))\r\noriginStr = \"AES128 ECB Pkcs5Padding test\"\r\n--加密模式：ECB；填充方式：Pkcs5Padding；密钥：1234567890123456；密钥长度：128 bit\r\nencodeStr = crypto.aes_encrypt(\"ECB\",\"PKCS5\",originStr,\"1234567890123456\")\r\nprint(originStr,\"encrypt\",string.toHex(encodeStr))\r\nlog.info(\"testCrypto.decrypt\",crypto.aes_decrypt(\"ECB\",\"PKCS5\",encodeStr,\"1234567890123456\"))\r\noriginStr = \"AES128 ECB Pkcs7Padding test\"\r\n--加密模式：ECB；填充方式：Pkcs7Padding；密钥：1234567890123456；密钥长度：128 bit\r\nencodeStr = crypto.aes_encrypt(\"ECB\",\"PKCS7\",originStr,\"1234567890123456\")\r\nprint(originStr,\"encrypt\",string.toHex(encodeStr))\r\nlog.info(\"testCrypto.decrypt\",crypto.aes_decrypt(\"ECB\",\"PKCS7\",encodeStr,\"1234567890123456\"))\r\noriginStr = \"AES192 ECB ZeroPadding test\"\r\n--加密模式：ECB；填充方式：ZeroPadding；密钥：123456789012345678901234；密钥长度：192 bit\r\nlocal encodeStr = crypto.aes_encrypt(\"ECB\",\"ZERO\",originStr,\"123456789012345678901234\")\r\nprint(originStr,\"encrypt\",string.toHex(encodeStr))\r\nlog.info(\"testCrypto.decrypt\",crypto.aes_decrypt(\"ECB\",\"ZERO\",encodeStr,\"123456789012345678901234\"))\r\noriginStr = \"AES192 ECB Pkcs5Padding test\"\r\n--加密模式：ECB；填充方式：Pkcs5Padding；密钥：123456789012345678901234；密钥长度：192 bit\r\nencodeStr = crypto.aes_encrypt(\"ECB\",\"PKCS5\",originStr,\"123456789012345678901234\")\r\nprint(originStr,\"encrypt\",string.toHex(encodeStr))\r\nlog.info(\"testCrypto.decrypt\",crypto.aes_decrypt(\"ECB\",\"PKCS5\",encodeStr,\"123456789012345678901234\"))\r\noriginStr = \"AES192 ECB Pkcs7Padding test\"\r\n--加密模式：ECB；填充方式：Pkcs7Padding；密钥：123456789012345678901234；密钥长度：192 bit\r\nencodeStr = crypto.aes_encrypt(\"ECB\",\"PKCS7\",originStr,\"123456789012345678901234\")\r\nprint(originStr,\"encrypt\",string.toHex(encodeStr))\r\nlog.info(\"testCrypto.decrypt\",crypto.aes_decrypt(\"ECB\",\"PKCS7\",encodeStr,\"123456789012345678901234\"))\r\noriginStr = \"AES256 ECB ZeroPadding test\"\r\n--加密模式：ECB；填充方式：ZeroPadding；密钥：12345678901234567890123456789012；密钥长度：256 bit\r\nlocal encodeStr = crypto.aes_encrypt(\"ECB\",\"ZERO\",originStr,\"12345678901234567890123456789012\")\r\nprint(originStr,\"encrypt\",string.toHex(encodeStr))\r\nlog.info(\"testCrypto.decrypt\",crypto.aes_decrypt(\"ECB\",\"ZERO\",encodeStr,\"12345678901234567890123456789012\"))\r\noriginStr = \"AES256 ECB Pkcs5Padding test\"\r\n--加密模式：ECB；填充方式：Pkcs5Padding；密钥：12345678901234567890123456789012；密钥长度：256 bit\r\nencodeStr = crypto.aes_encrypt(\"ECB\",\"PKCS5\",originStr,\"12345678901234567890123456789012\")\r\nprint(originStr,\"encrypt\",string.toHex(encodeStr))\r\nlog.info(\"testCrypto.decrypt\",crypto.aes_decrypt(\"ECB\",\"PKCS5\",encodeStr,\"12345678901234567890123456789012\"))\r\noriginStr = \"AES256 ECB Pkcs7Padding test\"\r\n--加密模式：ECB；填充方式：Pkcs7Padding；密钥：12345678901234567890123456789012；密钥长度：256 bit\r\nencodeStr = crypto.aes_encrypt(\"ECB\",\"PKCS7\",originStr,\"12345678901234567890123456789012\")\r\nprint(originStr,\"encrypt\",string.toHex(encodeStr))\r\nlog.info(\"testCrypto.decrypt\",crypto.aes_decrypt(\"ECB\",\"PKCS7\",encodeStr,\"12345678901234567890123456789012\"))\r\noriginStr = \"AES128 CBC ZeroPadding test\"\r\n--加密模式：CBC；填充方式：ZeroPadding；密钥：1234567890123456；密钥长度：128 bit；偏移量：1234567890666666\r\nlocal encodeStr = crypto.aes_encrypt(\"CBC\",\"ZERO\",originStr,\"1234567890123456\",\"1234567890666666\")\r\nprint(originStr,\"encrypt\",string.toHex(encodeStr))\r\nlog.info(\"testCrypto.decrypt\",crypto.aes_decrypt(\"CBC\",\"ZERO\",encodeStr,\"1234567890123456\",\"1234567890666666\"))\r\noriginStr = \"AES128 CBC Pkcs5Padding test\"\r\n--加密模式：CBC；填充方式：Pkcs5Padding；密钥：1234567890123456；密钥长度：128 bit；偏移量：1234567890666666\r\nencodeStr = crypto.aes_encrypt(\"CBC\",\"PKCS5\",originStr,\"1234567890123456\",\"1234567890666666\")\r\nprint(originStr,\"encrypt\",string.toHex(encodeStr))\r\nlog.info(\"testCrypto.decrypt\",crypto.aes_decrypt(\"CBC\",\"PKCS5\",encodeStr,\"1234567890123456\",\"1234567890666666\"))\r\noriginStr = \"AES128 CBC Pkcs7Padding test\"\r\n--加密模式：CBC；填充方式：Pkcs7Padding；密钥：1234567890123456；密钥长度：128 bit；偏移量：1234567890666666\r\nencodeStr = crypto.aes_encrypt(\"CBC\",\"PKCS7\",originStr,\"1234567890123456\",\"1234567890666666\")\r\nprint(originStr,\"encrypt\",string.toHex(encodeStr))\r\nlog.info(\"testCrypto.decrypt\",crypto.aes_decrypt(\"CBC\",\"PKCS7\",encodeStr,\"1234567890123456\",\"1234567890666666\"))\r\noriginStr = \"AES192 CBC ZeroPadding test\"\r\n--加密模式：CBC；填充方式：ZeroPadding；密钥：123456789012345678901234；密钥长度：192 bit；偏移量：1234567890666666\r\nlocal encodeStr = crypto.aes_encrypt(\"CBC\",\"ZERO\",originStr,\"123456789012345678901234\",\"1234567890666666\")\r\nprint(originStr,\"encrypt\",string.toHex(encodeStr))\r\nlog.info(\"testCrypto.decrypt\",crypto.aes_decrypt(\"CBC\",\"ZERO\",encodeStr,\"123456789012345678901234\",\"1234567890666666\"))\r\noriginStr = \"AES192 CBC Pkcs5Padding test\"\r\n--加密模式：CBC；填充方式：Pkcs5Padding；密钥：123456789012345678901234；密钥长度：192 bit；偏移量：1234567890666666\r\nencodeStr = crypto.aes_encrypt(\"CBC\",\"PKCS5\",originStr,\"123456789012345678901234\",\"1234567890666666\")\r\nprint(originStr,\"encrypt\",string.toHex(encodeStr))\r\nlog.info(\"testCrypto.decrypt\",crypto.aes_decrypt(\"CBC\",\"PKCS5\",encodeStr,\"123456789012345678901234\",\"1234567890666666\"))\r\noriginStr = \"AES192 CBC Pkcs7Padding test\"\r\n--加密模式：CBC；填充方式：Pkcs7Padding；密钥：123456789012345678901234；密钥长度：192 bit；偏移量：1234567890666666\r\nencodeStr = crypto.aes_encrypt(\"CBC\",\"PKCS7\",originStr,\"123456789012345678901234\",\"1234567890666666\")\r\nprint(originStr,\"encrypt\",string.toHex(encodeStr))\r\nlog.info(\"testCrypto.decrypt\",crypto.aes_decrypt(\"CBC\",\"PKCS7\",encodeStr,\"123456789012345678901234\",\"1234567890666666\"))\r\noriginStr = \"AES256 CBC ZeroPadding test\"\r\n--加密模式：CBC；填充方式：ZeroPadding；密钥：12345678901234567890123456789012；密钥长度：256 bit；偏移量：1234567890666666\r\nlocal encodeStr = crypto.aes_encrypt(\"CBC\",\"ZERO\",originStr,\"12345678901234567890123456789012\",\"1234567890666666\")\r\nprint(originStr,\"encrypt\",string.toHex(encodeStr))\r\nlog.info(\"testCrypto.decrypt\",crypto.aes_decrypt(\"CBC\",\"ZERO\",encodeStr,\"12345678901234567890123456789012\",\"1234567890666666\"))\r\noriginStr = \"AES256 CBC Pkcs5Padding test\"\r\n--加密模式：CBC；填充方式：Pkcs5Padding；密钥：12345678901234567890123456789012；密钥长度：256 bit；偏移量：1234567890666666\r\nencodeStr = crypto.aes_encrypt(\"CBC\",\"PKCS5\",originStr,\"12345678901234567890123456789012\",\"1234567890666666\")\r\nprint(originStr,\"encrypt\",string.toHex(encodeStr))\r\nlog.info(\"testCrypto.decrypt\",crypto.aes_decrypt(\"CBC\",\"PKCS5\",encodeStr,\"12345678901234567890123456789012\",\"1234567890666666\"))\r\noriginStr = \"AES256 CBC Pkcs7Padding test\"\r\n--加密模式：CBC；填充方式：Pkcs7Padding；密钥：12345678901234567890123456789012；密钥长度：256 bit；偏移量：1234567890666666\r\nencodeStr = crypto.aes_encrypt(\"CBC\",\"PKCS7\",originStr,\"12345678901234567890123456789012\",\"1234567890666666\")\r\nprint(originStr,\"encrypt\",string.toHex(encodeStr))\r\nlog.info(\"testCrypto.decrypt\",crypto.aes_decrypt(\"CBC\",\"PKCS7\",encodeStr,\"12345678901234567890123456789012\",\"1234567890666666\"))\r\noriginStr = \"AES128 CTR ZeroPadding test\"\r\n--加密模式：CTR；填充方式：ZeroPadding；密钥：1234567890123456；密钥长度：128 bit；偏移量：1234567890666666\r\nlocal encodeStr = crypto.aes_encrypt(\"CTR\",\"ZERO\",originStr,\"1234567890123456\",\"1234567890666666\")\r\nprint(originStr,\"encrypt\",string.toHex(encodeStr))\r\nlog.info(\"testCrypto.decrypt\",crypto.aes_decrypt(\"CTR\",\"ZERO\",encodeStr,\"1234567890123456\",\"1234567890666666\"))\r\noriginStr = \"AES128 CTR Pkcs5Padding test\"\r\n--加密模式：CTR；填充方式：Pkcs5Padding；密钥：1234567890123456；密钥长度：128 bit；偏移量：1234567890666666\r\nencodeStr = crypto.aes_encrypt(\"CTR\",\"PKCS5\",originStr,\"1234567890123456\",\"1234567890666666\")\r\nprint(originStr,\"encrypt\",string.toHex(encodeStr))\r\nlog.info(\"testCrypto.decrypt\",crypto.aes_decrypt(\"CTR\",\"PKCS5\",encodeStr,\"1234567890123456\",\"1234567890666666\"))\r\noriginStr = \"AES128 CTR Pkcs7Padding test\"\r\n--加密模式：CTR；填充方式：Pkcs7Padding；密钥：1234567890123456；密钥长度：128 bit；偏移量：1234567890666666\r\nencodeStr = crypto.aes_encrypt(\"CTR\",\"PKCS7\",originStr,\"1234567890123456\",\"1234567890666666\")\r\nprint(originStr,\"encrypt\",string.toHex(encodeStr))\r\nlog.info(\"testCrypto.decrypt\",crypto.aes_decrypt(\"CTR\",\"PKCS7\",encodeStr,\"1234567890123456\",\"1234567890666666\"))\r\noriginStr = \"AES128 CTR NonePadding test\"\r\n--加密模式：CTR；填充方式：NonePadding；密钥：1234567890123456；密钥长度：128 bit；偏移量：1234567890666666\r\nencodeStr = crypto.aes_encrypt(\"CTR\",\"NONE\",originStr,\"1234567890123456\",\"1234567890666666\")\r\nprint(originStr,\"encrypt\",string.toHex(encodeStr))\r\nlog.info(\"testCrypto.decrypt\",crypto.aes_decrypt(\"CTR\",\"NONE\",encodeStr,\"1234567890123456\",\"1234567890666666\"))\r\noriginStr = \"AES192 CTR ZeroPadding test\"\r\n--加密模式：CTR；填充方式：ZeroPadding；密钥：123456789012345678901234；密钥长度：192 bit；偏移量：1234567890666666\r\nlocal encodeStr = crypto.aes_encrypt(\"CTR\",\"ZERO\",originStr,\"123456789012345678901234\",\"1234567890666666\")\r\nprint(originStr,\"encrypt\",string.toHex(encodeStr))\r\nlog.info(\"testCrypto.decrypt\",crypto.aes_decrypt(\"CTR\",\"ZERO\",encodeStr,\"123456789012345678901234\",\"1234567890666666\"))\r\noriginStr = \"AES192 CTR Pkcs5Padding test\"\r\n--加密模式：CTR；填充方式：Pkcs5Padding；密钥：123456789012345678901234；密钥长度：192 bit；偏移量：1234567890666666\r\nencodeStr = crypto.aes_encrypt(\"CTR\",\"PKCS5\",originStr,\"123456789012345678901234\",\"1234567890666666\")\r\nprint(originStr,\"encrypt\",string.toHex(encodeStr))\r\nlog.info(\"testCrypto.decrypt\",crypto.aes_decrypt(\"CTR\",\"PKCS5\",encodeStr,\"123456789012345678901234\",\"1234567890666666\"))\r\noriginStr = \"AES192 CTR Pkcs7Padding test\"\r\n--加密模式：CTR；填充方式：Pkcs7Padding；密钥：123456789012345678901234；密钥长度：192 bit；偏移量：1234567890666666\r\nencodeStr = crypto.aes_encrypt(\"CTR\",\"PKCS7\",originStr,\"123456789012345678901234\",\"1234567890666666\")\r\nprint(originStr,\"encrypt\",string.toHex(encodeStr))\r\nlog.info(\"testCrypto.decrypt\",crypto.aes_decrypt(\"CTR\",\"PKCS7\",encodeStr,\"123456789012345678901234\",\"1234567890666666\"))\r\noriginStr = \"AES192 CTR NonePadding test\"\r\n--加密模式：CTR；填充方式：NonePadding；密钥：123456789012345678901234；密钥长度：192 bit；偏移量：1234567890666666\r\nencodeStr = crypto.aes_encrypt(\"CTR\",\"NONE\",originStr,\"123456789012345678901234\",\"1234567890666666\")\r\nprint(originStr,\"encrypt\",string.toHex(encodeStr))\r\nlog.info(\"testCrypto.decrypt\",crypto.aes_decrypt(\"CTR\",\"NONE\",encodeStr,\"123456789012345678901234\",\"1234567890666666\"))\r\noriginStr = \"AES256 CTR ZeroPadding test\"\r\n--加密模式：CTR；填充方式：ZeroPadding；密钥：12345678901234567890123456789012；密钥长度：256 bit；偏移量：1234567890666666\r\nlocal encodeStr = crypto.aes_encrypt(\"CTR\",\"ZERO\",originStr,\"12345678901234567890123456789012\",\"1234567890666666\")\r\nprint(originStr,\"encrypt\",string.toHex(encodeStr))\r\nlog.info(\"testCrypto.decrypt\",crypto.aes_decrypt(\"CTR\",\"ZERO\",encodeStr,\"12345678901234567890123456789012\",\"1234567890666666\"))\r\noriginStr = \"AES256 CTR Pkcs5Padding test\"\r\n--加密模式：CTR；填充方式：Pkcs5Padding；密钥：12345678901234567890123456789012；密钥长度：256 bit；偏移量：1234567890666666\r\nencodeStr = crypto.aes_encrypt(\"CTR\",\"PKCS5\",originStr,\"12345678901234567890123456789012\",\"1234567890666666\")\r\nprint(originStr,\"encrypt\",string.toHex(encodeStr))\r\nlog.info(\"testCrypto.decrypt\",crypto.aes_decrypt(\"CTR\",\"PKCS5\",encodeStr,\"12345678901234567890123456789012\",\"1234567890666666\"))\r\n\r\noriginStr = \"AES256 CTR Pkcs7Padding test\"\r\n--加密模式：CTR；填充方式：Pkcs7Padding；密钥：12345678901234567890123456789012；密钥长度：256 bit；偏移量：1234567890666666\r\nencodeStr = crypto.aes_encrypt(\"CTR\",\"PKCS7\",originStr,\"12345678901234567890123456789012\",\"1234567890666666\")\r\nprint(originStr,\"encrypt\",string.toHex(encodeStr))\r\nlog.info(\"testCrypto.decrypt\",crypto.aes_decrypt(\"CTR\",\"PKCS7\",encodeStr,\"12345678901234567890123456789012\",\"1234567890666666\"))\r\n\r\noriginStr = \"AES256 CTR NonePadding test\"\r\n--加密模式：CTR；填充方式：NonePadding；密钥：12345678901234567890123456789012；密钥长度：256 bit；偏移量：1234567890666666\r\nencodeStr = crypto.aes_encrypt(\"CTR\",\"NONE\",originStr,\"12345678901234567890123456789012\",\"1234567890666666\")\r\nprint(originStr,\"encrypt\",string.toHex(encodeStr))\r\nlog.info(\"testCrypto.decrypt\",crypto.aes_decrypt(\"CTR\",\"NONE\",encodeStr,\"12345678901234567890123456789012\",\"1234567890666666\"))\r\n",
        "prefix": "crypto.aes_encrypt()"
    },
    "crypto.base64_decode()": {
        "body": "crypto.base64_decode()",
        "description": "base64解密\r\n返回值：\r\n  解密后的数据\r\n例子：\r\nprint(\"base64_decode\",crypto.base64_decode(encodestr,slen(encodestr)))\r\n-- base64_decode\t123456\r\n",
        "prefix": "crypto.base64_decode()"
    },
    "crypto.base64_encode()": {
        "body": "crypto.base64_encode()",
        "description": "base64加密\r\n返回值：\r\n  加密后的数据\r\n例子：\r\nlocal originstr = \"123456\"\r\nlocal encodestr = crypto.base64_encode(originstr,slen(originstr))\r\nprint(\"base64_encode\",encodestr)\r\n--base64_encode\tMTIzNDU2\r\n",
        "prefix": "crypto.base64_encode()"
    },
    "crypto.crc16()": {
        "body": "crypto.crc16()",
        "description": "CRC16校验算法\r\n返回值：\r\n  校验计算结果\r\n例子：\r\nlocal originStr = \"sdfdsfdsfdsffdsfdsfsdfs1234\"\r\nprint(\"testCrypto.crc16_MODBUS\",string.format(\"%04X\",crypto.crc16(\"MODBUS\",originStr)))\r\nprint(\"testCrypto.crc16_IBM\",string.format(\"%04X\",crypto.crc16(\"IBM\",originStr)))\r\nprint(\"testCrypto.crc16_X25\",string.format(\"%04X\",crypto.crc16(\"X25\",originStr)))\r\nprint(\"testCrypto.crc16_MAXIM\",string.format(\"%04X\",crypto.crc16(\"MAXIM\",originStr)))\r\nprint(\"testCrypto.crc16_USB\",string.format(\"%04X\",crypto.crc16(\"USB\",originStr)))\r\nprint(\"testCrypto.crc16_CCITT\",string.format(\"%04X\",crypto.crc16(\"CCITT\",originStr)))\r\nprint(\"testCrypto.crc16_CCITT-FALSE\",string.format(\"%04X\",crypto.crc16(\"CCITT-FALSE\",originStr)))\r\nprint(\"testCrypto.crc16_XMODEM\",string.format(\"%04X\",crypto.crc16(\"XMODEM\",originStr)))\r\nprint(\"testCrypto.crc16_DNP\",string.format(\"%04X\",crypto.crc16(\"DNP\",originStr)))\r\n",
        "prefix": "crypto.crc16()"
    },
    "crypto.crc32()": {
        "body": "crypto.crc32()",
        "description": "CRC32校验算法\r\n返回值：\r\n  校验计算结果\r\n例子：\r\nlocal originstr = \"sdfdsfdsfdsffdsfdsfsdfs1234\"\r\nprint(\"crc32\",string.format(\"%08X\",crypto.crc32(originstr,slen(originstr))))\r\n--crc32\t2FC153F9\r\n",
        "prefix": "crypto.crc32()"
    },
    "crypto.flow_md5()": {
        "body": "crypto.flow_md5()",
        "description": "流式md5算法\r\n返回值：\r\n  无\r\n例子：\r\nlocal fmd5Obj=crypto.flow_md5()\r\nlocal testTable={\"lqlq666lqlq946\",\"07946lq94607946\",\"lq54075407540707946\"}\r\nfor i=1, #(testTable) do\r\n    fmd5Obj:update(testTable[i])\r\nend\r\nprint(\"testCrypto.flowMd5Test\",fmd5Obj:hexdigest())\r\n",
        "prefix": "crypto.flow_md5()"
    },
    "crypto.hmac_md5()": {
        "body": "crypto.hmac_md5()",
        "description": "hmac_md5算法测试\r\n返回值：\r\n  加密后的数据\r\n例子：\r\nlocal originstr = \"asdasdsadas\"\r\nlocal signkey = \"123456\"\r\nprint(\"hmac_md5\",crypto.hmac_md5(originstr,slen(originstr),signkey,slen(signkey)))\r\n-- hmac_md5\t38A7B18DC5F6543849DC49F06FADE3CC\r\n",
        "prefix": "crypto.hmac_md5()"
    },
    "crypto.hmac_sha1()": {
        "body": "crypto.hmac_sha1()",
        "description": "hmac_sha1算法\r\n返回值：\r\n  加密后的数据\r\n例子：\r\nlocal originstr = \"asdasdsadasweqcdsjghjvcb\"\r\nlocal signkey = \"12345689012345\"\r\nprint(\"hmac_sha1\",crypto.hmac_sha1(originstr,slen(originstr),signkey,slen(signkey)))\r\n--hmac_sha1\tE3BB109BA59AF6A1F677157E8EC6B21349B9220F\r\n",
        "prefix": "crypto.hmac_sha1()"
    },
    "crypto.md5()": {
        "body": "crypto.md5()",
        "description": "md5算法，支持计算文件的md5值\r\n返回值：\r\n  加密后的数据\r\n例子：\r\nlocal originstr = \"sdfdsfdsfdsffdsfdsfsdfs1234\"\r\nprint(\"md5\",crypto.md5(originstr,slen(originstr)))\r\n--md5\t235B69FBC9E75C4FD5E8C59F9CB16500\r\n",
        "prefix": "crypto.md5()"
    },
    "crypto.sha1()": {
        "body": "crypto.sha1()",
        "description": "sha1算法\r\n返回值：\r\n  加密后的数据\r\n例子：\r\nlocal originstr = \"sdfdsfdsfdsffdsfdsfsdfs1234\"\r\nprint(\"sha1\",crypto.sha1(originstr,slen(originstr)))\r\n-- sha1\t16EBE919119B9B54C8AF6B4F2A09C18B6B6D8218\r\n",
        "prefix": "crypto.sha1()"
    },
    "crypto.sha256()": {
        "body": "crypto.sha256()",
        "description": "sha256算法\r\n返回值：\r\n  加密后的数据\r\n例子：\r\nlocal originStr = \"sdfdsfdsfdsffdsfdsfsdfs1234\"\r\nprint(\"testCrypto.sha256\",crypto.sha256(originStr))\r\n",
        "prefix": "crypto.sha256()"
    },
    "crypto.xxtea_encrypt()": {
        "body": "crypto.xxtea_encrypt()",
        "description": "xxtea加密算法\r\n返回值：\r\n  加密/解密数据\r\n例子：\r\nlocal text = \"Hello World!\";\r\nlocal key = \"07946\";\r\nlocal encrypt_data = crypto.xxtea_encrypt(text, key);\r\nprint(\"testCrypto.xxteaTest\",\"xxtea_encrypt:\"..encrypt_data)\r\nlocal decrypt_data = crypto.xxtea_decrypt(encrypt_data, key);\r\nprint(\"testCrypto.xxteaTest\",\"decrypt_data:\"..decrypt_data)\r\n",
        "prefix": "crypto.xxtea_encrypt()"
    },
    "debug.debug": {
        "body": "debug.debug()",
        "description": "debug.debug ()",
        "prefix": "debug.debug"
    },
    "debug.getfenv": {
        "body": "debug.getfenv(${0:...})",
        "description": "debug.getfenv (o)",
        "prefix": "debug.getfenv"
    },
    "debug.gethook": {
        "body": "debug.gethook( ${1:[thread]} )",
        "description": "debug.gethook ([thread])",
        "prefix": "debug.gethook"
    },
    "debug.getinfo": {
        "body": "debug.getinfo( ${1:[thread],}${2:f}${3:[, what]} )",
        "description": "debug.getinfo ([thread,] f [, what])",
        "prefix": "debug.getinfo"
    },
    "debug.getlocal": {
        "body": "debug.getlocal( ${1:[thread],}${2:f}${3:[, local]} )",
        "description": "debug.getlocal ([thread,] f, local)",
        "prefix": "debug.getlocal"
    },
    "debug.getmetatable": {
        "body": "debug.getmetatable( ${1:value} )",
        "description": "debug.getmetatable (value)",
        "prefix": "debug.getmetatable"
    },
    "debug.getregistry": {
        "body": "debug.getregistry()",
        "description": "debug.getregistry ()",
        "prefix": "debug.getregistry"
    },
    "debug.getupvalue": {
        "body": "debug.getupvalue( ${1:f}, ${2:up} )",
        "description": "debug.getupvalue (f, up)",
        "prefix": "debug.getupvalue"
    },
    "debug.getuservalue": {
        "body": "debug.getuservalue(${0:...})",
        "description": "debug.getuservalue (u)",
        "prefix": "debug.getuservalue"
    },
    "debug.getuservalue ": {
        "body": "debug.getuservalue ( ${1:u} )",
        "description": "debug.getuservalue (u)",
        "prefix": "debug.getuservalue "
    },
    "debug.setfenv": {
        "body": "debug.setfenv(${0:...})",
        "description": "debug.setfenv (object, table)",
        "prefix": "debug.setfenv"
    },
    "debug.sethook": {
        "body": "debug.sethook( ${1:[thead,]}${2:hook}, ${3:mask}${4:[, count]} )",
        "description": "debug.sethook ([thread,] hook, mask [, count])",
        "prefix": "debug.sethook"
    },
    "debug.setlocal": {
        "body": "debug.setlocal( ${1:[thead,]}${2:level}, ${3:local}, ${4:value} )",
        "description": "debug.setlocal ([thread,] level, local, value)",
        "prefix": "debug.setlocal"
    },
    "debug.setmetatable": {
        "body": "debug.setmetatable( ${1:value}, ${2:table} )",
        "description": "debug.setmetatable (value, table)",
        "prefix": "debug.setmetatable"
    },
    "debug.setupvalue": {
        "body": "debug.setupvalue( ${1:f}, ${2:up}, ${3:value} )",
        "description": "debug.setupvalue (f, up, value)",
        "prefix": "debug.setupvalue"
    },
    "debug.setuservalue": {
        "body": "debug.setuservalue( ${1:udata}, ${2:value} )",
        "description": "debug.setuservalue (udata, value)",
        "prefix": "debug.setuservalue"
    },
    "debug.traceback": {
        "body": "debug.traceback( ${1:[thread,]}${2:[message]}${3:[, level]} )",
        "description": "debug.traceback ([thread,] [message [, level]])",
        "prefix": "debug.traceback"
    },
    "debug.upvalueid": {
        "body": "debug.upvalueid( ${1:f}, ${2:n})",
        "description": "debug.upvalueid (f, n)",
        "prefix": "debug.upvalueid"
    },
    "debug.upvaluejoin": {
        "body": "debug.upvaluejoin( ${1:f1}, ${2:n1}, ${3:f2}, ${4:n2} )",
        "description": "debug.upvaluejoin (f1, n1, f2, n2)",
        "prefix": "debug.upvaluejoin"
    },
    "disp.clear()": {
        "body": "disp.clear()",
        "description": "清除缓冲区内容，注意不会刷新到屏幕上，只有在update时才会执行刷屏动作\r\n返回值：\r\n  无",
        "prefix": "disp.clear()"
    },
    "disp.drawrect()": {
        "body": "disp.drawrect()",
        "description": "绘制矩形，并且填充颜色。填充色可以自行设置也可不填充颜色值格式RGB565。\r\n返回值：\r\n  无",
        "prefix": "disp.drawrect()"
    },
    "disp.getlcdinfo()": {
        "body": "disp.getlcdinfo()",
        "description": "获取LCD分辨率的宽度和高度(单位是像素)\r\n返回值：\r\n  WIDTH ：宽度\r\n",
        "prefix": "disp.getlcdinfo()"
    },
    "disp.init()": {
        "body": "disp.init()",
        "description": "初始化显示接口语法\r\n返回值：\r\n  无",
        "prefix": "disp.init()"
    },
    "disp.loadfont()": {
        "body": "disp.loadfont()",
        "description": "加载字体\r\n返回值：\r\n  fontid-返回加载后的字体id 用于setfont设置字体",
        "prefix": "disp.loadfont()"
    },
    "disp.putimage()": {
        "body": "disp.putimage()",
        "description": "在坐标(x,y)处显示图片，目前仅支持bmp和png格式，这个接口只会将显示数据写到缓冲区，只有在执行了update了以后才会真正的刷屏。最后面的四个参数是规定了从file中截取某一部分区域\r\n返回值：\r\n  无",
        "prefix": "disp.putimage()"
    },
    "disp.putqrcode()": {
        "body": "disp.putqrcode()",
        "description": "显示二维码\r\n返回值：\r\n  无",
        "prefix": "disp.putqrcode()"
    },
    "disp.puttext()": {
        "body": "disp.puttext()",
        "description": "显示字符串\r\n返回值：\r\n  无\r\n例子：\r\ndisp.puttext(\"欢迎使用Luat\",16,0) --从坐标16,0位置开始显示\"欢迎使用Luat\"\r\n",
        "prefix": "disp.puttext()"
    },
    "disp.setbkcolor()": {
        "body": "disp.setbkcolor()",
        "description": "设置背景色\r\n返回值：\r\n  无",
        "prefix": "disp.setbkcolor()"
    },
    "disp.setcolor()": {
        "body": "disp.setcolor()",
        "description": "设置前景色\r\n返回值：\r\n  无",
        "prefix": "disp.setcolor()"
    },
    "disp.setfont()": {
        "body": "disp.setfont()",
        "description": "设置字体\r\n返回值：\r\n  oldfontid-返回旧的字体id",
        "prefix": "disp.setfont()"
    },
    "disp.sleep()": {
        "body": "disp.sleep()",
        "description": "休眠显示模块",
        "prefix": "disp.sleep()"
    },
    "disp.update()": {
        "body": "disp.update()",
        "description": "将缓冲区内容刷新到屏幕上\r\n返回值：\r\n  无",
        "prefix": "disp.update()"
    },
    "dofile": {
        "body": "dofile(${1:[filename]})",
        "description": "dofile ([filename])",
        "prefix": "dofile"
    },
    "elif": {
        "body": "else if ${1:condition} then\n\t${0:-- body}\n",
        "description": "elif",
        "prefix": "elif"
    },
    "errDump.appendErr(s)": {
        "body": "errDump.appendErr(${1:s})",
        "description": "追加错误信息到LIB_ERR_FILE文件中（文件最多允许存储5K字节的数据）\r\n返回值：\r\nbool result，true表示成功，false或者nil表示失败\r\n例子：\r\nerrDump.appendErr(\"net working timeout!\")\r\n",
        "prefix": "errDump.appendErr(s)"
    },
    "errDump.request(addr, period)": {
        "body": "errDump.request(${1:addr},${2: period})",
        "description": "配置调试服务器地址，启动错误信息上报给调试服务器的功能，上报成功后，会清除错误信息\r\n返回值：\r\nbool result，成功返回true，失败返回nil\r\n例子：\r\nerrDump.request(\"http://www.user_server.com/errdump\")\r\nerrDump.request(\"udp://www.user_server.com:8081\")\r\nerrDump.request(\"tcp://www.user_server.com:8082\")\r\nerrDump.request(\"tcp://www.user_server.com:8082\",6*3600*1000)\r\n",
        "prefix": "errDump.request(addr, period)"
    },
    "errDump.setNetworkLog(flag)": {
        "body": "errDump.setNetworkLog(${1:flag})",
        "description": "配置网络错误日志开关\r\n返回值：\r\n无\r\n例子：\r\nerrDump.setNetworkLog(true)\r\n",
        "prefix": "errDump.setNetworkLog(flag)"
    },
    "error": {
        "body": "error(${0:...})",
        "description": "error (message [, level])",
        "prefix": "error"
    },
    "file:close": {
        "body": "file:close(${0:...})",
        "description": "file:close ()",
        "prefix": "file:close"
    },
    "file:close()": {
        "body": "file:close()",
        "description": "关闭文件句柄\r\n返回值：\r\n  无",
        "prefix": "file:close()"
    },
    "file:flush": {
        "body": "file:flush(${0:...})",
        "description": "file:flush ()",
        "prefix": "file:flush"
    },
    "file:flush()": {
        "body": "file:flush()",
        "description": "向文件写入缓冲中的所有数据\r\n返回值：\r\n  无",
        "prefix": "file:flush()"
    },
    "file:lines": {
        "body": "file:lines(${0:...})",
        "description": "file:lines ()",
        "prefix": "file:lines"
    },
    "file:read": {
        "body": "file:read(${0:...})",
        "description": "file:read (...)",
        "prefix": "file:read"
    },
    "file:read()": {
        "body": "file:read()",
        "description": "读文件file， 指定的格式决定了要读什么。\r\n返回值：\r\n  对于每种格式，函数返回读出的字符对应的字符串或数字。 若不能以该格式对应读出数据则返回nil\r\n例子：\r\nlocal file = io.open(\"test.txt\", \"r\")\r\nprint(file:read(\"*l\"))  --this is test 1\r\nprint(file:read(\"*n\"))  --nil\r\nprint(file:read(2))  --th\r\n",
        "prefix": "file:read()"
    },
    "file:seek": {
        "body": "file:seek(${0:...})",
        "description": "file:seek ([whence] [, offset])",
        "prefix": "file:seek"
    },
    "file:seek()": {
        "body": "file:seek()",
        "description": "设置和获取当前文件位置。\r\n返回值：\r\n  成功则返回最终的文件位置(按字节),失败则返回nil加错误信息\r\n例子：\r\nlocal file = io.open(\"test.txt\", \"r+\")\r\nprint(file:seek(\"end\"))\t\t--30\r\nprint(file:seek(\"set\"))\t\t--0\r\nprint(file:seek())\t        --0\r\nprint(file:seek(\"cur\", 10))\t\t--10\r\nprint(file:seek(\"cur\"))\t\t--10\r\nprint(file:read(1))\t\t\t--s\r\nprint(file:seek(\"cur\"))\t\t--11\r\nfile:close()\r\n",
        "prefix": "file:seek()"
    },
    "file:setvbuf": {
        "body": "file:setvbuf(${0:...})",
        "description": "file:setvbuf (mode [, size])",
        "prefix": "file:setvbuf"
    },
    "file:write": {
        "body": "file:write(${0:...})",
        "description": "file:write (...)",
        "prefix": "file:write"
    },
    "file:write ()": {
        "body": "file:write ()",
        "description": "将参数的值逐个写入file。\r\n返回值：\r\n  成功时，函数返回 file。 否则返回nil加错误描述字符串。",
        "prefix": "file:write ()"
    },
    "for": {
        "body": "for ${1:i}=${2:1},${3:10} do\n\t${0:print(i)}\nend",
        "description": "for i=1,10",
        "prefix": "for"
    },
    "fori": {
        "body": "for ${1:i},${2:v} in ipairs(${3:table_name}) do\n\t${0:print(i,v)}\nend",
        "description": "for i,v in ipairs()",
        "prefix": "fori"
    },
    "forp": {
        "body": "for ${1:k},${2:v} in pairs(${3:table_name}) do\n\t${0:print(k,v)}\nend",
        "description": "for k,v in pairs()",
        "prefix": "forp"
    },
    "fun": {
        "body": "function ${1:function_name}( ${2:...} )\n\t${0:-- body}\nend",
        "description": "function",
        "prefix": "fun"
    },
    "function": {
        "body": "function ${1:function_name}( ${2:...} )\n\t${0:-- body}\nend",
        "description": "function",
        "prefix": "function"
    },
    "getfenv": {
        "body": "getfenv(${0:...})",
        "description": "getfenv ([f])",
        "prefix": "getfenv"
    },
    "getmetatable": {
        "body": "getmetatable(${1:object})",
        "description": "getmetatable (object)",
        "prefix": "getmetatable"
    },
    "gizwits.checkUpdate(hard_version, soft_version)": {
        "body": "gizwits.checkUpdate(${1:hard_version},${2: soft_version})",
        "description": "手动检查更新\r\n返回值：\r\nstring，结果\r\n例子：\r\ncheckUpdate(\"00000001\",\"00000001\")\r\n",
        "prefix": "gizwits.checkUpdate(hard_version, soft_version)"
    },
    "gizwits.on(evt, cbFnc)": {
        "body": "gizwits.on(${1:evt},${2: cbFnc})",
        "description": "注册事件的处理函数\r\n返回值：\r\nnil\r\n例子：\r\ngizwits.on(\"transmissionRev\",rcvTransCbFnc)\r\n",
        "prefix": "gizwits.on(evt, cbFnc)"
    },
    "gizwits.publish(topic, payload, qos, cbFnc, cbPara)": {
        "body": "gizwits.publish(${1:topic},${2: payload},${3: qos},${4: cbFnc},${5: cbPara})",
        "description": "发布一条消息\r\n返回值：\r\nnil\r\n例子：\r\npublish(topic,msg,0)\r\npublish(topic,msgbody,0,{cb=cbFnc,para=cbPara})\r\n",
        "prefix": "gizwits.publish(topic, payload, qos, cbFnc, cbPara)"
    },
    "gizwits.setup(PRODUCT_KEY, PRODUCT_SECRET, getDeviceName, getDeviceSecret, getDeviceId, setDeviceId, getAuthKey, m2mHT, extra, server, port)": {
        "body": "gizwits.setup(${1:PRODUCT_KEY},${2: PRODUCT_SECRET},${3: getDeviceName},${4: getDeviceSecret},${5: getDeviceId},${6: setDeviceId},${7: getAuthKey},${8: m2mHT},${9: extra},${10: server},${11: port})",
        "description": "初始化机智云注册所需要的数据\r\n返回值：\r\nnil\r\n例子：\r\ngizwits.setup(\"PRODUCT_KEY\",\"PRODUCT_SECRET\",getDeviceName,getDeviceSecret)\r\n",
        "prefix": "gizwits.setup(PRODUCT_KEY, PRODUCT_SECRET, getDeviceName, getDeviceSecret, getDeviceId, setDeviceId, getAuthKey, m2mHT, extra, server, port)"
    },
    "gizwits.transmissionSend(flag, ccmd, sn, cmd, topic)": {
        "body": "gizwits.transmissionSend(${1:flag},${2: ccmd},${3: sn},${4: cmd},${5: topic})",
        "description": "发布一条透传消息\r\n返回值：\r\nnil\r\n例子：\r\ngizwits.transmissionSend(0,string.fromHex(\"0094\"),string.fromHex(\"00000001\"),\"cmd\",\"dev2app/12345/67890\"))  --回复ack\r\n",
        "prefix": "gizwits.transmissionSend(flag, ccmd, sn, cmd, topic)"
    },
    "gps.DEFAULT": {
        "body": "gps.DEFAULT",
        "description": "常量值，GPS应用模式1.",
        "prefix": "gps.DEFAULT"
    },
    "gps.TIMER": {
        "body": "gps.TIMER",
        "description": "常量值，GPS应用模式3.",
        "prefix": "gps.TIMER"
    },
    "gps.TIMERORSUC": {
        "body": "gps.TIMERORSUC",
        "description": "常量值，GPS应用模式2.",
        "prefix": "gps.TIMERORSUC"
    },
    "gps.close(mode, para)": {
        "body": "gps.close(${1:mode},${2: para})",
        "description": "关闭一个“GPS应用”\r\n返回值：\r\nnil\r\n例子：\r\nGPS应用模式和GPS应用标记唯一确定一个“GPS应用”，调用本接口关闭时，mode和para.tag要和gps.open打开一个“GPS应用”时传入的mode和para.tag保持一致\r\ngps.close(gps.DEFAULT,{tag=\"TEST1\"})\r\ngps.close(gps.TIMERORSUC,{tag=\"TEST2\"})\r\ngps.close(gps.TIMER,{tag=\"TEST3\"})\r\n--另见：open,DEFAULT,TIMERORSUC,TIMER\r\n",
        "prefix": "gps.close(mode, para)"
    },
    "gps.closeAll()": {
        "body": "gps.closeAll()",
        "description": "关闭所有“GPS应用”\r\n返回值：\r\nnil\r\n例子：\r\ngps.closeAll()\r\n--另见：open,DEFAULT,TIMERORSUC,TIMER\r\n",
        "prefix": "gps.closeAll()"
    },
    "gps.getAltitude()": {
        "body": "gps.getAltitude()",
        "description": "获取海拔\r\n返回值：\r\nnumber altitude，海拔，单位米\r\n例子：\r\ngps.getAltitude()\r\n",
        "prefix": "gps.getAltitude()"
    },
    "gps.getCourse()": {
        "body": "gps.getCourse()",
        "description": "获取方向角\r\n返回值：\r\nnumber course，方向角\r\n例子：\r\ngps.getCourse()\r\n",
        "prefix": "gps.getCourse()"
    },
    "gps.getGgaloc()": {
        "body": "gps.getGgaloc()",
        "description": "获取GGA语句中度分格式的经纬度信息\r\n返回值：\r\nstring lng，度分格式的经度值(dddmm.mmmm)，西经会添加一个-前缀，无效时为\"\"；例如\"12112.3456\"表示东经121度12.3456分，\"-12112.3456\"表示西经121度12.3456分\r\n例子：\r\ngps.getGgaloc()\r\n",
        "prefix": "gps.getGgaloc()"
    },
    "gps.getGsv()": {
        "body": "gps.getGsv()",
        "description": "获取GSV语句中的可见卫星的信噪比\r\n返回值：\r\nstring gsv，信噪比\r\n例子：\r\ngps.getGsv()\r\n",
        "prefix": "gps.getGsv()"
    },
    "gps.getLocation(typ)": {
        "body": "gps.getLocation(${1:typ})",
        "description": "获取度格式的经纬度信息\r\n返回值：\r\ntable location\r\n例如typ为\"DEGREE_MINUTE\"时返回{lngType=\"E\",lng=\"12128.44954\",latType=\"N\",lat=\"3114.50931\"}\r\n例如typ不是\"DEGREE_MINUTE\"时返回{lngType=\"E\",lng=\"121.123456\",latType=\"N\",lat=\"31.123456\"}\r\nlngType：string类型，表示经度类型，取值\"E\"，\"W\"\r\nlng：string类型，表示度格式的经度值，无效时为\"\"\r\nlatType：string类型，表示纬度类型，取值\"N\"，\"S\"\r\nlat：string类型，表示度格式的纬度值，无效时为\"\"\r\n例子：\r\ngps.getLocation()\r\n",
        "prefix": "gps.getLocation(typ)"
    },
    "gps.getOrgSpeed()": {
        "body": "gps.getOrgSpeed()",
        "description": "获取原始速度,字符串带浮点\r\n返回值：\r\nnumber speed 海里每小时的速度\r\n例子：\r\ngps.getOrgSpeed()\r\n",
        "prefix": "gps.getOrgSpeed()"
    },
    "gps.getSateSn()": {
        "body": "gps.getSateSn()",
        "description": "获取GSA语句中的可见卫星号\r\n返回值：\r\nstring viewedSateId，可用卫星号，\"\"表示无效\r\n例子：\r\ngps.getSateSn()\r\n",
        "prefix": "gps.getSateSn()"
    },
    "gps.getSep()": {
        "body": "gps.getSep()",
        "description": "获取定位使用的大地高\r\n返回值：\r\nnumber sep，大地高\r\n例子：\r\ngps.getSep()\r\n",
        "prefix": "gps.getSep()"
    },
    "gps.getSpeed()": {
        "body": "gps.getSpeed()",
        "description": "获取速度\r\n返回值：\r\nnumber kmSpeed，第一个返回值为公里每小时的速度\r\n例子：\r\ngps.getSpeed()\r\n",
        "prefix": "gps.getSpeed()"
    },
    "gps.getUsedSateCnt()": {
        "body": "gps.getUsedSateCnt()",
        "description": "获取定位使用的卫星个数\r\n返回值：\r\nnumber count，定位使用的卫星个数\r\n例子：\r\ngps.getUsedSateCnt()\r\n",
        "prefix": "gps.getUsedSateCnt()"
    },
    "gps.getUtcTime()": {
        "body": "gps.getUtcTime()",
        "description": "获取RMC语句中的UTC时间\r\n返回值：\r\ntable utcTime，UTC时间，nil表示无效，例如{year=2018,month=4,day=24,hour=11,min=52,sec=10}\r\n例子：\r\ngps.getUtcTime()\r\n",
        "prefix": "gps.getUtcTime()"
    },
    "gps.getViewedSateCnt()": {
        "body": "gps.getViewedSateCnt()",
        "description": "获取可见卫星的个数\r\n返回值：\r\nnumber count，可见卫星的个数\r\n例子：\r\ngps.getViewedSateCnt()\r\n",
        "prefix": "gps.getViewedSateCnt()"
    },
    "gps.isActive(mode, para)": {
        "body": "gps.isActive(${1:mode},${2: para})",
        "description": "判断一个“GPS应用”是否处于激活状态\r\n返回值：\r\nbool result，处于激活状态返回true，否则返回nil\r\n例子：\r\nGPS应用模式和GPS应用标记唯一确定一个“GPS应用”，调用本接口查询状态时，mode和para.tag要和gps.open打开一个“GPS应用”时传入的mode和para.tag保持一致\r\ngps.isActive(gps.DEFAULT,{tag=\"TEST1\"})\r\ngps.isActive(gps.TIMERORSUC,{tag=\"TEST2\"})\r\ngps.isActive(gps.TIMER,{tag=\"TEST3\"})\r\n--另见：open,DEFAULT,TIMERORSUC,TIMER\r\n",
        "prefix": "gps.isActive(mode, para)"
    },
    "gps.isFix()": {
        "body": "gps.isFix()",
        "description": "获取GPS模块是否定位成功\r\n返回值：\r\nbool result，true表示定位成功，false或者nil表示定位失败\r\n例子：\r\ngps.isFix()\r\n",
        "prefix": "gps.isFix()"
    },
    "gps.isOpen()": {
        "body": "gps.isOpen()",
        "description": "获取GPS模块是否处于开启状态\r\n返回值：\r\nbool result，true表示开启状态，false或者nil表示关闭状态\r\n例子：\r\ngps.isOpen()\r\n",
        "prefix": "gps.isOpen()"
    },
    "gps.open(mode, para)": {
        "body": "gps.open(${1:mode},${2: para})",
        "description": "打开一个“GPS应用”\r\n返回值：\r\nnil\r\n例子：\r\ngps.open(gps.DEFAULT,{tag=\"TEST1\",cb=test1Cb})\r\ngps.open(gps.TIMERORSUC,{tag=\"TEST2\",val=60,cb=test2Cb})\r\ngps.open(gps.TIMER,{tag=\"TEST3\",val=120,cb=test3Cb})\r\n--另见：DEFAULT,TIMERORSUC,TIMER\r\n",
        "prefix": "gps.open(mode, para)"
    },
    "gps.setAerialMode(gps, beidou, glonass, galieo)": {
        "body": "gps.setAerialMode(${1:gps},${2: beidou},${3: glonass},${4: galieo})",
        "description": "设置GPS模块搜星模式.\r\n返回值：\r\nnil\r\n例子：\r\ngps.setAeriaMode(1,1,0,0)\r\n",
        "prefix": "gps.setAerialMode(gps, beidou, glonass, galieo)"
    },
    "gps.setLocationFilter(seconds)": {
        "body": "gps.setLocationFilter(${1:seconds})",
        "description": "设置GPS定位成功后经纬度的过滤时间.\r\n返回值：\r\nnil\r\n例子：\r\ngps.setLocationFilter(2)\r\n",
        "prefix": "gps.setLocationFilter(seconds)"
    },
    "gps.setNemaReportFreq(rmc, gga, gsa, gsv, vtg, gll)": {
        "body": "gps.setNemaReportFreq(${1:rmc},${2: gga},${3: gsa},${4: gsv},${5: vtg},${6: gll})",
        "description": "设置NEMA语句的输出频率.\r\n返回值：\r\nnil\r\n例子：\r\ngps.setNemaReportFreq(5,0,0,0,0,0)\r\n",
        "prefix": "gps.setNemaReportFreq(rmc, gga, gsa, gsv, vtg, gll)"
    },
    "gps.setNmeaMode(mode, cbFnc)": {
        "body": "gps.setNmeaMode(${1:mode},${2: cbFnc})",
        "description": "设置NMEA数据处理模式.\r\n返回值：\r\nnil\r\n例子：\r\ngps.setNmeaMode(0)\r\ngps.setNmeaMode(1,cbFnc)\r\ngps.setNmeaMode(2,cbFnc)\r\n",
        "prefix": "gps.setNmeaMode(mode, cbFnc)"
    },
    "gps.setParseItem(utcTime, gsv, gsaId)": {
        "body": "gps.setParseItem(${1:utcTime},${2: gsv},${3: gsaId})",
        "description": "设置是否需要解析的字段\r\n返回值：\r\n无\r\n例子：\r\ngps.setParseItem(true,true,true)\r\n",
        "prefix": "gps.setParseItem(utcTime, gsv, gsaId)"
    },
    "gps.setPowerCbFnc(cbFnc)": {
        "body": "gps.setPowerCbFnc(${1:cbFnc})",
        "description": "设置GPS模块供电控制的回调函数\r\n返回值：\r\nnil\r\n例子：\r\ngps.setPowerCbFnc(cbFnc)\r\n",
        "prefix": "gps.setPowerCbFnc(cbFnc)"
    },
    "gps.setRunMode(mode, runTm, sleepTm)": {
        "body": "gps.setRunMode(${1:mode},${2: runTm},${3: sleepTm})",
        "description": "设置GPS模块的运行模式.\r\n返回值：\r\nnil\r\n例子：\r\ngps.setRunMode(0,1000)\r\ngps.setRunMode(1,5000,2000)\r\n",
        "prefix": "gps.setRunMode(mode, runTm, sleepTm)"
    },
    "gps.setUart(id, baudrate, databits, parity, stopbits)": {
        "body": "gps.setUart(${1:id},${2: baudrate},${3: databits},${4: parity},${5: stopbits})",
        "description": "设置GPS模块和GSM模块之间数据通信的串口参数\r\n返回值：\r\nnil\r\n例子：\r\ngps.setUart(2,115200,8,uart.PAR_NONE,uart.STOP_1)\r\n",
        "prefix": "gps.setUart(id, baudrate, databits, parity, stopbits)"
    },
    "gps.writeCmd(cmd, isFull)": {
        "body": "gps.writeCmd(${1:cmd},${2: isFull})",
        "description": "GPS串口写命令操作\r\n返回值：\r\nnil\r\n例子：\r\ngps.writeCmd(cmd)\r\n",
        "prefix": "gps.writeCmd(cmd, isFull)"
    },
    "gpsv2.close(id, fnc)": {
        "body": "gpsv2.close(${1:id},${2: fnc})",
        "description": "关闭GPS模块\r\n返回值：\r\n无\r\n例子：\r\ngpsv2.close()\r\n",
        "prefix": "gpsv2.close(id, fnc)"
    },
    "gpsv2.getAltitude()": {
        "body": "gpsv2.getAltitude()",
        "description": "获取海拔\r\n返回值：\r\nnumber altitude，海拔，单位米\r\n例子：\r\ngpsv2.getAltitude()\r\n",
        "prefix": "gpsv2.getAltitude()"
    },
    "gpsv2.getAzimuth()": {
        "body": "gpsv2.getAzimuth()",
        "description": "获取方向角\r\n返回值：\r\nnumber Azimuth，方位角\r\n例子：\r\ngpsv2.getAzimuth()\r\n",
        "prefix": "gpsv2.getAzimuth()"
    },
    "gpsv2.getBDGsv()": {
        "body": "gpsv2.getBDGsv()",
        "description": "获取BDGSV解析结果\r\n返回值：\r\ntable, GSV解析后的数组\r\n例子：\r\ngpsv2.getBDGsv()\r\n",
        "prefix": "gpsv2.getBDGsv()"
    },
    "gpsv2.getCentLocation()": {
        "body": "gpsv2.getCentLocation()",
        "description": "获取度分格式的经纬度信息ddmm.mmmm\r\n返回值：\r\nstring,string,返回度格式的字符串经度,维度,符号(正东负西,正北负南)\r\n例子：\r\ngpsv2.getCentLocation()\r\n",
        "prefix": "gpsv2.getCentLocation()"
    },
    "gpsv2.getDegLocation()": {
        "body": "gpsv2.getDegLocation()",
        "description": "获取度格式的经纬度信息dd.dddddd\r\n返回值：\r\nstring,string,固件为非浮点时返回度格式的字符串经度,维度,符号(正东负西,正北负南)\r\n例子：\r\ngpsv2.getLocation()\r\n",
        "prefix": "gpsv2.getDegLocation()"
    },
    "gpsv2.getGPGsv()": {
        "body": "gpsv2.getGPGsv()",
        "description": "获取GPGSV解析结果\r\n返回值：\r\ntable, GSV解析后的数组\r\n例子：\r\ngpsv2.getGPGsv()\r\n",
        "prefix": "gpsv2.getGPGsv()"
    },
    "gpsv2.getIntLocation()": {
        "body": "gpsv2.getIntLocation()",
        "description": "获取返回值为度的10&7方的整数值（度*10^7的值）\r\n返回值：\r\nnumber,number,INT32整数型,经度,维度,符号(正东负西,正北负南)\r\n例子：\r\ngpsv2.getIntLocation()\r\n",
        "prefix": "gpsv2.getIntLocation()"
    },
    "gpsv2.getSateSn()": {
        "body": "gpsv2.getSateSn()",
        "description": "获取GSA语句中的可见卫星号\r\n返回值：\r\nstring viewedSateId，可用卫星号，\"\"表示无效\r\n例子：\r\ngpsv2.getSateSn()\r\n",
        "prefix": "gpsv2.getSateSn()"
    },
    "gpsv2.getSep()": {
        "body": "gpsv2.getSep()",
        "description": "获取定位使用的大地高\r\n返回值：\r\nnumber sep，大地高\r\n例子：\r\ngpsv2.getSep()\r\n",
        "prefix": "gpsv2.getSep()"
    },
    "gpsv2.getSpeed()": {
        "body": "gpsv2.getSpeed()",
        "description": "获取速度\r\n返回值：\r\nnumber kmSpeed，第一个返回值为公里每小时的速度\r\n例子：\r\ngpsv2.getSpeed()\r\n",
        "prefix": "gpsv2.getSpeed()"
    },
    "gpsv2.getUsedSateCnt()": {
        "body": "gpsv2.getUsedSateCnt()",
        "description": "获取定位使用的卫星个数\r\n返回值：\r\nnumber count，定位使用的卫星个数\r\n例子：\r\ngpsv2.getUsedSateCnt()\r\n",
        "prefix": "gpsv2.getUsedSateCnt()"
    },
    "gpsv2.getUtcStamp()": {
        "body": "gpsv2.getUtcStamp()",
        "description": "获取gps的UTC时间戳\r\n返回值：\r\n无\r\n例子：\r\ngpsv2.getUtcStamp()\r\n",
        "prefix": "gpsv2.getUtcStamp()"
    },
    "gpsv2.getUtcTime()": {
        "body": "gpsv2.getUtcTime()",
        "description": "获取RMC语句中的UTC时间\r\n返回值：\r\ntable utcTime，UTC时间，nil表示无效，例如{year=2018,month=4,day=24,hour=11,min=52,sec=10}\r\n例子：\r\ngpsv2.getUtcTime()\r\n",
        "prefix": "gpsv2.getUtcTime()"
    },
    "gpsv2.getViewedSateCnt()": {
        "body": "gpsv2.getViewedSateCnt()",
        "description": "获取可见卫星的个数\r\n返回值：\r\nnumber count，可见卫星的个数\r\n例子：\r\ngpsv2.getViewedSateCnt()\r\n",
        "prefix": "gpsv2.getViewedSateCnt()"
    },
    "gpsv2.isFix()": {
        "body": "gpsv2.isFix()",
        "description": "获取GPS模块是否定位成功\r\n返回值：\r\nbool result，true表示定位成功，false或者nil表示定位失败\r\n例子：\r\ngpsv2.isFix()\r\n",
        "prefix": "gpsv2.isFix()"
    },
    "gpsv2.isOpen()": {
        "body": "gpsv2.isOpen()",
        "description": "获取GPS模块是否处于开启状态\r\n返回值：\r\nbool result，true表示开启状态，false或者nil表示关闭状态\r\n例子：\r\ngpsv2.isOpen()\r\n",
        "prefix": "gpsv2.isOpen()"
    },
    "gpsv2.open(id, baudrate, mode, sleepTm, fnc)": {
        "body": "gpsv2.open(${1:id},${2: baudrate},${3: mode},${4: sleepTm},${5: fnc})",
        "description": "打开GPS模块\r\n返回值：\r\n无\r\n例子：\r\ngpsv2.open()\r\ngpsv2.open(2, 115200, 0, 1)  -- 打开GPS，串口2，波特率115200，正常功耗模式，1秒1个点\r\ngpsv2.open(2, 115200, 2, 5) -- 打开GPS，串口2，波特率115200，周期低功耗模式1秒输出，5秒睡眠\r\n",
        "prefix": "gpsv2.open(id, baudrate, mode, sleepTm, fnc)"
    },
    "gpsv2.restart(r)": {
        "body": "gpsv2.restart(${1:r})",
        "description": "重启GPS模块\r\n返回值：\r\n无\r\n例子：\r\ngpsv2.restart()\r\n",
        "prefix": "gpsv2.restart(r)"
    },
    "gpsv2.setAerialMode(gps, beidou, glonass, galieo)": {
        "body": "gpsv2.setAerialMode(${1:gps},${2: beidou},${3: glonass},${4: galieo})",
        "description": "设置GPS模块搜星模式.\r\n返回值：\r\nnil\r\n例子：\r\ngpsv2.setAeriaMode(1,1,0,0)\r\n",
        "prefix": "gpsv2.setAerialMode(gps, beidou, glonass, galieo)"
    },
    "gpsv2.setReport(tm)": {
        "body": "gpsv2.setReport(${1:tm})",
        "description": "设置NMEA消息上报的间隔\r\n返回值：\r\n无\r\n例子：\r\ngpsv2.setReport(tm)\r\n",
        "prefix": "gpsv2.setReport(tm)"
    },
    "gpsv2.setRunMode(mode, runTm, sleepTm)": {
        "body": "gpsv2.setRunMode(${1:mode},${2: runTm},${3: sleepTm})",
        "description": "设置GPS模块的运行模式.\r\n返回值：\r\nnil\r\n例子：\r\ngpsv2.setRunMode(0,1000)\r\ngpsv2.setRunMode(1,5000,2000)\r\n",
        "prefix": "gpsv2.setRunMode(mode, runTm, sleepTm)"
    },
    "http.request(method, url, cert, head, body, timeout, cbFnc, rcvFileName)": {
        "body": "http.request(${1:method},${2: url},${3: cert},${4: head},${5: body},${6: timeout},${7: cbFnc},${8: rcvFileName})",
        "description": "发送HTTP请求\r\n返回值：\r\nstring rcvFilePath，如果传入了rcvFileName，则返回对应的完整路径；其余情况都返回nil\r\n例子：\r\nhttp.request(\"GET\",\"www.lua.org\",nil,nil,nil,30000,cbFnc)\r\nhttp.request(\"GET\",\"http://www.lua.org\",nil,nil,nil,30000,cbFnc)\r\nhttp.request(\"GET\",\"http://www.lua.org:80\",nil,nil,nil,30000,cbFnc,\"download.bin\")\r\nhttp.request(\"GET\",\"www.lua.org/about.html\",nil,nil,nil,30000,cbFnc)\r\nhttp.request(\"GET\",\"www.lua.org:80/about.html\",nil,nil,nil,30000,cbFnc)\r\nhttp.request(\"GET\",\"http://wiki.openluat.com/search.html?q=123\",nil,nil,nil,30000,cbFnc)\r\nhttp.request(\"POST\",\"www.test.com/report.html\",nil,{Head1=\"ValueData1\"},\"BodyData\",30000,cbFnc)\r\nhttp.request(\"POST\",\"www.test.com/report.html\",nil,{Head1=\"ValueData1\",Head2=\"ValueData2\"},{[1]=\"string1\",[2] ={file=\"/ldata/test.jpg\"},[3]=\"string2\"},30000,cbFnc)\r\nhttp.request(\"GET\",\"https://www.baidu.com\",{caCert=\"ca.crt\"})\r\nhttp.request(\"GET\",\"https://www.baidu.com\",{caCert=\"ca.crt\",clientCert = \"client.crt\",clientKey = \"client.key\"})\r\nhttp.request(\"GET\",\"https://www.baidu.com\",{caCert=\"ca.crt\",clientCert = \"client.crt\",clientKey = \"client.key\",clientPassword = \"123456\"})\r\n",
        "prefix": "http.request(method, url, cert, head, body, timeout, cbFnc, rcvFileName)"
    },
    "httpv2.request(method, url, timeout, params, data, ctype, basic, headers, cert, fnc)": {
        "body": "httpv2.request(${1:method},${2: url},${3: timeout},${4: params},${5: data},${6: ctype},${7: basic},${8: headers},${9: cert},${10: fnc})",
        "description": "HTTP客户端\r\n返回值：\r\nstring,table,string,正常返回response_code, response_header, response_body\r\n例子：\r\nlocal c, h, b = httpv2.request(url, method, headers, body)\r\nlocal r, e  = httpv2.request(\"http://wrong.url/ \")\r\n",
        "prefix": "httpv2.request(method, url, timeout, params, data, ctype, basic, headers, cert, fnc)"
    },
    "i2c.close()": {
        "body": "i2c.close()",
        "description": "关闭 I2C 接口\r\n返回值：\r\n  无",
        "prefix": "i2c.close()"
    },
    "i2c.read()": {
        "body": "i2c.read()",
        "description": "读取指定寄存器地址 reg 的数据内容\r\n返回值：\r\n  返回读取的数据，二进制数据会包含非可见字符，请使用 string.byte 打印数据流\r\n例子：\r\n--从从设备的寄存器地址cmd[i]中读1字节的数据，并且打印出来\r\n    local cmd,i = {0x1B,0x00,0x6A,0x01,0x1E,0x20,0x21,0x04,0x1B,0x00,0x1B,0xDA,0x1B,0xDA}\r\n    for i=1,#cmd,2 do\r\n        --向从设备的寄存器地址cmd[i]中写1字节的数据cmd[i+1]\r\n        i2c.write(i2cid,cmd[i],cmd[i+1])\r\n        --从从设备的寄存器地址cmd[i]中读1字节的数据，并且打印出来\r\n        print(\"testI2c.init1\",string.format(\"%02X\",cmd[i]),string.toHex(i2c.read(i2cid,cmd[i],1)))\r\n    end\r\n",
        "prefix": "i2c.read()"
    },
    "i2c.recv()": {
        "body": "i2c.recv()",
        "description": "向从设备读取数据\r\n返回值：\r\n  返回读取的数据，二进制数据会包含非可见字符，请使用 string.byte 打印数据流\r\n例子：\r\n--向从设备i2cslaveaddr发送寄存器地址cmd[i]\r\ni2c.send(i2cid,i2cslaveaddr,cmd[i])\r\n--读取从设备i2cslaveaddr寄存器内的1个字节的数据，并且打印出来\r\nprint(\"testI2c.init\",string.format(\"%02X\",cmd[i]),string.toHex(i2c.recv(i2cid,i2cslaveaddr,1)))\r\n",
        "prefix": "i2c.recv()"
    },
    "i2c.send()": {
        "body": "i2c.send()",
        "description": "向从设备写数据\r\n返回值：\r\n  传输成功的字节数\r\n例子：\r\nlocal cmd,i = {0x1B,0x00,0x6A,0x01,0x1E,0x20,0x21,0x04,0x1B,0x00,0x1B,0xDA,0x1B,0xDA}\r\nfor i=1,#cmd,2 do\r\n  --向从设备i2cslaveaddr发送寄存器地址cmd[i]\r\n  i2c.send(i2cid,i2cslaveaddr,cmd[i])\r\n  --向从设备i2cslaveaddr发送要写入从设备寄存器内的数据cmd[i+1]\r\n  i2c.send(i2cid,i2cslaveaddr,cmd[i+1])\r\nend\r\n",
        "prefix": "i2c.send()"
    },
    "i2c.setup()": {
        "body": "i2c.setup()",
        "description": "打开i2c接口\r\n返回值：\r\n  可以根据返回的频率值判断是否成功打开 i2c\r\n例子：\r\n--使用i2c.send和i2c.recv的setup\r\nif i2c.setup(i2cid,i2c.SLOW) ~= i2c.SLOW then\r\n  print(\"init fail\")\r\n  return\r\nend\r\n\r\n--使用i2c.write和i2c.read的setup\r\nif i2c.setup(i2cid,i2c.SLOW,i2cslaveaddr) ~= i2c.SLOW then\r\n  print(\"init1 fail\")\r\n  return\r\nend\r\n",
        "prefix": "i2c.setup()"
    },
    "i2c.write()": {
        "body": "i2c.write()",
        "description": "往指定的寄存器地址 reg 传输数据\r\n返回值：\r\n  传输成功的字节数\r\n例子：\r\nlocal cmd,i = {0x1B,0x00,0x6A,0x01,0x1E,0x20,0x21,0x04,0x1B,0x00,0x1B,0xDA,0x1B,0xDA}\r\nfor i=1,#cmd,2 do\r\n  --向从设备的寄存器地址cmd[i]中写1字节的数据cmd[i+1]\r\n  i2c.write(i2cid,cmd[i],cmd[i+1])\r\nend\r\n",
        "prefix": "i2c.write()"
    },
    "if": {
        "body": "if ${1:condition} then\n\t${0:-- body}\nend",
        "description": "if",
        "prefix": "if"
    },
    "ifel": {
        "body": "if ${1:condition} then\n\t${2:-- body}\nelse\n\t${0:-- body}\nend",
        "description": "ifel",
        "prefix": "ifel"
    },
    "io.close": {
        "body": "io.close(${0:...})",
        "description": "io.close ([file])",
        "prefix": "io.close"
    },
    "io.exists(path)": {
        "body": "io.exists(${1:path})",
        "description": "判断文件是否存在\r\n返回值：\r\nboole,存在为true,不存在为false\r\n例子：\r\nlocal ex = io.exists(\"/ldata/call.mp3\")\r\n",
        "prefix": "io.exists(path)"
    },
    "io.fileSize(path)": {
        "body": "io.fileSize(${1:path})",
        "description": "返回文件大小\r\n返回值：\r\nnumber ,文件大小\r\n例子：\r\nlocan cnt = io.fileSize(\"/ldata/call.txt\")\r\n",
        "prefix": "io.fileSize(path)"
    },
    "io.flush": {
        "body": "io.flush(${0:...})",
        "description": "io.flush ()",
        "prefix": "io.flush"
    },
    "io.input": {
        "body": "io.input(${0:...})",
        "description": "io.input ([file])",
        "prefix": "io.input"
    },
    "io.lines": {
        "body": "io.lines(${0:...})",
        "description": "io.lines ([filename])",
        "prefix": "io.lines"
    },
    "io.open": {
        "body": "io.open(${0:...})",
        "description": "io.open (filename [, mode])",
        "prefix": "io.open"
    },
    "io.open()": {
        "body": "io.open()",
        "description": "这个函数用字符串mode 指定的模式打开一个文件。\r\n返回值：\r\n  返回新的文件句柄。 当出错时，返回 nil加错误消息。\r\n例子：\r\nfile = io.open(\"test.lua\", \"r\")\r\n",
        "prefix": "io.open()"
    },
    "io.output": {
        "body": "io.output(${0:...})",
        "description": "io.output ([file])",
        "prefix": "io.output"
    },
    "io.pathInfo(path)": {
        "body": "io.pathInfo(${1:path})",
        "description": "将文件路径分解为table信息\r\n返回值：\r\ntable,{dirname=\"/ldata/\",filename=\"call.txt\",basename=\"call\",extname=\".txt\"}\r\n例子：\r\nloca p = io.pathInfo(\"/ldata/call.txt\")\r\n",
        "prefix": "io.pathInfo(path)"
    },
    "io.popen": {
        "body": "io.popen(${0:...})",
        "description": "io.popen (prog [, mode])",
        "prefix": "io.popen"
    },
    "io.read": {
        "body": "io.read(${0:...})",
        "description": "io.read (...)",
        "prefix": "io.read"
    },
    "io.readFile(path)": {
        "body": "io.readFile(${1:path})",
        "description": "读取文件并返回文件的内容\r\n返回值：\r\nstring,文件的内容,文件不存在返回nil\r\n例子：\r\nlocal c = io.readFile(\"/ldata/call.txt\")\r\n",
        "prefix": "io.readFile(path)"
    },
    "io.readStream(path, offset, len)": {
        "body": "io.readStream(${1:path},${2: offset},${3: len})",
        "description": "返回指定位置读取的字符串\r\n返回值：\r\nstring,返回要读取的数据,读取失败返回nil",
        "prefix": "io.readStream(path, offset, len)"
    },
    "io.tmpfile": {
        "body": "io.tmpfile(${0:...})",
        "description": "io.tmpfile ()",
        "prefix": "io.tmpfile"
    },
    "io.type": {
        "body": "io.type(${0:...})",
        "description": "io.type (obj)",
        "prefix": "io.type"
    },
    "io.write": {
        "body": "io.write(${0:...})",
        "description": "io.write (...)",
        "prefix": "io.write"
    },
    "io.writeFile(path, content, mode)": {
        "body": "io.writeFile(${1:path},${2: content},${3: mode})",
        "description": "写入文件指定的内容,默认为覆盖二进制模式\r\n返回值：\r\nstring,文件的内容\r\n例子：\r\nlocal c = io.writeFile(\"/ldata/call.txt\",\"test\")\r\n",
        "prefix": "io.writeFile(path, content, mode)"
    },
    "ipairs": {
        "body": "ipairs(${0:...})",
        "description": "ipairs (t)",
        "prefix": "ipairs"
    },
    "json.decode()": {
        "body": "json.decode()",
        "description": "json解析\r\n返回值：\r\n  解析内容，table类型\r\n解析结果，true为成功，false为失败\r\n错误信息\r\n例子：\r\n-- 正确json字符串\r\nlocal wrongOrigin = \"{\\\":\\\"VALUE3\\\",\\\"KEY4\\\":\\\"VALUE4\\\",\\\"KEY2\\\":\\\"VALUE2\\\",\\\"KEY1\\\":\\\"VALUE1\\\",\\\"KEY5\\\":{\\\"KEY5_2\\\":\\\"VALU5_2\\\",\\\"KEY5_1\\\":\\\"VALU5_1\\\"},\\\"KEY6\\\":[1,2,3]}\"\r\nlocal origin = \"{\\\"KEY3\\\":\\\"VALUE3\\\",\\\"KEY4\\\":\\\"VALUE4\\\",\\\"KEY2\\\":\\\"VALUE2\\\",\\\"KEY1\\\":\\\"VALUE1\\\",\\\"KEY5\\\":{\\\"KEY5_2\\\":\\\"VALU5_2\\\",\\\"KEY5_1\\\":\\\"VALU5_1\\\"},\\\"KEY6\\\":[1,2,3]}\"\r\nlocal tjsondata,result,errinfo = json.decode(origin)\r\nif result then\r\n    print(tjsondata[\"KEY1\"])\r\n    print(tjsondata[\"KEY2\"])\r\n    print(tjsondata[\"KEY3\"])\r\n    print(tjsondata[\"KEY4\"])\r\n    print(tjsondata[\"KEY5\"][\"KEY5_1\"],tjsondata[\"KEY5\"][\"KEY5_2\"])\r\n    print(tjsondata[\"KEY6\"][1],tjsondata[\"KEY6\"][2],tjsondata[\"KEY6\"][3])\r\nelse\r\n\tprint(\"json.decode error\",errinfo)\r\nend\r\n--origin：正确输出\r\n--wrongOrigin：json.decode error\tExpected colon but found invalid token at character 5\r\n",
        "prefix": "json.decode()"
    },
    "json.encode()": {
        "body": "json.encode()",
        "description": "json编译\r\n返回值：\r\n  json格式字符串\r\n例子：\r\nlocal torigin =\r\n{\r\n    KEY1 = \"VALUE1\",\r\n    KEY2 = \"VALUE2\",\r\n    KEY3 = \"VALUE3\",\r\n    KEY4 = \"VALUE4\",\r\n    KEY5 = {KEY5_1=\"VALU5_1\",KEY5_2=\"VALU5_2\"},\r\n    KEY6 = {1,2,3},\r\n}\r\n\r\nlocal jsondata = json.encode(torigin)\r\n--[[\r\n{\"KEY3\":\"VALUE3\",\"KEY4\":\"VALUE4\",\"KEY2\":\"VALUE2\",\"KEY1\":\"VALUE1\",\"KEY5\":{\"KEY5_2\":\"VALU5_2\",\"KEY5_1\":\"VALU5_1\"}},\"KEY6\":[1,2,3]}\r\n]]\r\n",
        "prefix": "json.encode()"
    },
    "lbsLoc.request(cbFnc, reqAddr, timeout, productKey, host, port, reqTime, reqWifi)": {
        "body": "lbsLoc.request(${1:cbFnc},${2: reqAddr},${3: timeout},${4: productKey},${5: host},${6: port},${7: reqTime},${8: reqWifi})",
        "description": "发送根据基站查询经纬度请求（仅支持中国区域的位置查询）\r\n返回值：\r\nnil\r\n例子：\r\nlbsLoc.request(cbFnc)\r\nlbsLoc.request(cbFnc,true)\r\nlbsLoc.request(cbFnc,nil,20000)\r\n",
        "prefix": "lbsLoc.request(cbFnc, reqAddr, timeout, productKey, host, port, reqTime, reqWifi)"
    },
    "led.blinkPwm(ledPin, light, dark)": {
        "body": "led.blinkPwm(${1:ledPin},${2: light},${3: dark})",
        "description": "闪烁指示灯\r\n返回值：\r\nnil\r\n例子：\r\nled.blinkPwm(lenPin,500,500)\r\n-- 调用函数需要使用任务支持\r\n",
        "prefix": "led.blinkPwm(ledPin, light, dark)"
    },
    "led.breateLed(ledPin)": {
        "body": "led.breateLed(${1:ledPin})",
        "description": "呼吸灯\r\n返回值：\r\nnil\r\n例子：\r\nled.breateLed(ledPin)\r\n-- 调用函数需要使用任务支持\r\n",
        "prefix": "led.breateLed(ledPin)"
    },
    "led.levelLed(ledPin, bl, bd, cnt, gap)    ": {
        "body": "led.levelLed(${1:ledPin},${2: bl},${3: bd},${4: cnt},${5: gap})    ",
        "description": "等级指示灯\r\n返回值：\r\nnil\r\n例子：\r\nled.leveled(ledPin,200,200,4,1000)\r\n-- 调用函数需要使用任务支持\r\n",
        "prefix": "led.levelLed(ledPin, bl, bd, cnt, gap)    "
    },
    "load": {
        "body": "load(${0:...})",
        "description": "load (func [, chunkname])",
        "prefix": "load"
    },
    "loadfile": {
        "body": "loadfile(${0:...})",
        "description": "loadfile ([filename])",
        "prefix": "loadfile"
    },
    "loadstring": {
        "body": "loadstring(${0:...})",
        "description": "loadstring (string [, chunkname])",
        "prefix": "loadstring"
    },
    "local": {
        "body": "local ${1:x} = ${0:1}",
        "description": "local x = 1",
        "prefix": "local"
    },
    "log.debug(tag, ...)": {
        "body": "log.debug(${1:tag},${2: ...})",
        "description": "输出debug级别的日志\r\n返回值：\r\nnil\r\n例子：\r\ndebug('moduleA', 'log content')\r\n",
        "prefix": "log.debug(tag, ...)"
    },
    "log.error(tag, ...)": {
        "body": "log.error(${1:tag},${2: ...})",
        "description": "输出error级别的日志\r\n返回值：\r\nnil\r\n例子：\r\nerror('moduleA', 'log content')\r\n",
        "prefix": "log.error(tag, ...)"
    },
    "log.fatal(tag, ...)": {
        "body": "log.fatal(${1:tag},${2: ...})",
        "description": "输出fatal级别的日志\r\n返回值：\r\nnil\r\n例子：\r\nfatal('moduleA', 'log content')\r\n",
        "prefix": "log.fatal(tag, ...)"
    },
    "log.info(tag, ...)": {
        "body": "log.info(${1:tag},${2: ...})",
        "description": "输出info级别的日志\r\n返回值：\r\nnil\r\n例子：\r\ninfo('moduleA', 'log content')\r\n",
        "prefix": "log.info(tag, ...)"
    },
    "log.openTrace(v, uartid, baudrate)": {
        "body": "log.openTrace(${1:v},${2: uartid},${3: baudrate})",
        "description": "开启或者关闭print的打印输出功能\r\n返回值：\r\nnil\r\n例子：\r\nsys.openTrace(1,nil,921600)\r\n",
        "prefix": "log.openTrace(v, uartid, baudrate)"
    },
    "log.trace(tag, ...)": {
        "body": "log.trace(${1:tag},${2: ...})",
        "description": "输出trace级别的日志\r\n返回值：\r\nnil\r\n例子：\r\ntrace('moduleA', 'log content')\r\n",
        "prefix": "log.trace(tag, ...)"
    },
    "log.warn(tag, ...)": {
        "body": "log.warn(${1:tag},${2: ...})",
        "description": "输出warn级别的日志\r\n返回值：\r\nnil\r\n例子：\r\nwarn('moduleA', 'log content')\r\n",
        "prefix": "log.warn(tag, ...)"
    },
    "math.abs": {
        "body": "math.abs( ${1:x} )",
        "description": "math.abs",
        "prefix": "math.abs"
    },
    "math.abs()": {
        "body": "math.abs()",
        "description": "计算绝对值\r\n返回值：\r\n  返回x的绝对值。",
        "prefix": "math.abs()"
    },
    "math.acos": {
        "body": "math.acos( ${1:x} )",
        "description": "math.acos",
        "prefix": "math.acos"
    },
    "math.acos()": {
        "body": "math.acos()",
        "description": "计算反余弦值\r\n返回值：\r\n  返回x的反余弦值（用弧度表示）。",
        "prefix": "math.acos()"
    },
    "math.asin": {
        "body": "math.asin( ${1:x} )",
        "description": "math.asin",
        "prefix": "math.asin"
    },
    "math.asin()": {
        "body": "math.asin()",
        "description": "计算反正弦值\r\n返回值：\r\n  返回x的反正弦值（用弧度表示）。",
        "prefix": "math.asin()"
    },
    "math.atan": {
        "body": "math.atan( ${1:y}${2:[, x]} )",
        "description": "math.atan",
        "prefix": "math.atan"
    },
    "math.atan()": {
        "body": "math.atan()",
        "description": "计算反正切值\r\n返回值：\r\n  返回 y/x 的反正切值（用弧度表示）。",
        "prefix": "math.atan()"
    },
    "math.atan2": {
        "body": "math.atan2(${0:...})",
        "description": "math.atan2 (y, x)",
        "prefix": "math.atan2"
    },
    "math.ceil": {
        "body": "math.ceil( ${1:x} )",
        "description": "math.ceil",
        "prefix": "math.ceil"
    },
    "math.ceil()": {
        "body": "math.ceil()",
        "description": "计算最小整数值\r\n返回值：\r\n  返回不小于 x 的最小整数值。",
        "prefix": "math.ceil()"
    },
    "math.cos": {
        "body": "math.cos( ${1:x} )",
        "description": "math.cos",
        "prefix": "math.cos"
    },
    "math.cos()": {
        "body": "math.cos()",
        "description": "计算余弦值\r\n返回值：\r\n  返回 x 的余弦",
        "prefix": "math.cos()"
    },
    "math.cosh": {
        "body": "math.cosh(${0:...})",
        "description": "math.cosh (x)",
        "prefix": "math.cosh"
    },
    "math.deg": {
        "body": "math.deg( ${1:x} )",
        "description": "math.deg",
        "prefix": "math.deg"
    },
    "math.deg()": {
        "body": "math.deg()",
        "description": "弧度转换为角度\r\n返回值：\r\n  返回转换后的角度值",
        "prefix": "math.deg()"
    },
    "math.exp": {
        "body": "math.exp( ${1:x} )",
        "description": "math.exp",
        "prefix": "math.exp"
    },
    "math.exp()": {
        "body": "math.exp()",
        "description": "计算 *ex* （*e*为自然对数的底 ）的值\r\n返回值：\r\n   *ex* （e 为自然对数的底 ）的值",
        "prefix": "math.exp()"
    },
    "math.floor": {
        "body": "math.floor( ${1:x} )",
        "description": "math.floor",
        "prefix": "math.floor"
    },
    "math.floor()": {
        "body": "math.floor()",
        "description": "计算不大于 x 的最大整数值。\r\n返回值：\r\n  返回不大于 x 的最大整数值。",
        "prefix": "math.floor()"
    },
    "math.fmod": {
        "body": "math.fmod( ${1:x},${2:y} )",
        "description": "math.fmod",
        "prefix": "math.fmod"
    },
    "math.fmod()": {
        "body": "math.fmod()",
        "description": "计算 x 除以 y，将商向零圆整后的余数\r\n返回值：\r\n  返回 x 除以 y，将商向零圆整后的余数。",
        "prefix": "math.fmod()"
    },
    "math.frexp": {
        "body": "math.frexp(${0:...})",
        "description": "math.frexp (x)",
        "prefix": "math.frexp"
    },
    "math.huge": {
        "body": "math.huge",
        "description": "浮点数 HUGE_VAL， 这个数比任何数字值都大。\r\n返回值：\r\n  无",
        "prefix": "math.huge"
    },
    "math.ldexp": {
        "body": "math.ldexp(${0:...})",
        "description": "math.ldexp (m, e)",
        "prefix": "math.ldexp"
    },
    "math.log": {
        "body": "math.log( ${1:x}${2:[, base]} )",
        "description": "math.log",
        "prefix": "math.log"
    },
    "math.log()": {
        "body": "math.log()",
        "description": "计算指定底的 x 的对数。 默认的 base 是 *e* （因此此函数返回 x 的自然对数）。\r\n返回值：\r\n  返回以指定底的 x 的对数",
        "prefix": "math.log()"
    },
    "math.log10": {
        "body": "math.log10(${0:...})",
        "description": "math.log10 (x)",
        "prefix": "math.log10"
    },
    "math.math.randomseed": {
        "body": "math.math.randomseed( ${1:x} )",
        "description": "math.math.randomseed",
        "prefix": "math.math.randomseed"
    },
    "math.max": {
        "body": "math.max( ${1:x},${2:...} )",
        "description": "math.max",
        "prefix": "math.max"
    },
    "math.max()": {
        "body": "math.max()",
        "description": "计算参数中最大的值， 大小由 Lua 操作 < 决定。\r\n返回值：\r\n  返回参数中最大的值",
        "prefix": "math.max()"
    },
    "math.maxinteger": {
        "body": "math.maxinteger",
        "description": "最大值的整数。\r\n返回值：\r\n  无",
        "prefix": "math.maxinteger"
    },
    "math.min": {
        "body": "math.min( ${1:x},${2:...} )",
        "description": "math.min",
        "prefix": "math.min"
    },
    "math.min()": {
        "body": "math.min()",
        "description": "返回参数中最小的值， 大小由 Lua 操作 < 决定。\r\n返回值：\r\n  返回参数中最小的值。",
        "prefix": "math.min()"
    },
    "math.mininteger": {
        "body": "math.mininteger",
        "description": "最小值的整数。\r\n返回值：\r\n  无",
        "prefix": "math.mininteger"
    },
    "math.modf": {
        "body": "math.modf( ${1:x} )",
        "description": "math.modf",
        "prefix": "math.modf"
    },
    "math.modf()": {
        "body": "math.modf()",
        "description": "计算 x 的整数部分和小数部分。\r\n返回值：\r\n  返回 x 的整数部分和小数部分。 第二个结果一定是浮点数。",
        "prefix": "math.modf()"
    },
    "math.pi": {
        "body": "math.pi",
        "description": "*π* 的值。\r\n返回值：\r\n  无",
        "prefix": "math.pi"
    },
    "math.pow": {
        "body": "math.pow(${0:...})",
        "description": "math.pow (x, y)",
        "prefix": "math.pow"
    },
    "math.rad": {
        "body": "math.rad(${0:...})",
        "description": "math.rad (x)",
        "prefix": "math.rad"
    },
    "math.rad()": {
        "body": "math.rad()",
        "description": "将角 x 从角度转换为弧度。\r\n返回值：\r\n  角 x 从角度转换为弧度值",
        "prefix": "math.rad()"
    },
    "math.random": {
        "body": "math.random( ${1:[m]}${2:[, n]} )",
        "description": "math.random",
        "prefix": "math.random"
    },
    "math.random()": {
        "body": "math.random()",
        "description": "随机数\r\n返回值：\r\n  当不带参数调用时， 返回一个 [0,1) 区间内一致分布的浮点伪随机数。 \r\n当以两个整数 m 与 n调用时， math.random返回一个 [m, n]区间 内一致分布的整数伪随机数。 （值 *m-n* 不能是负数，且必须在 Lua 整数的表示范围内。） \r\n调用 math.random(n) 等价于 math.random(1,n)。",
        "prefix": "math.random()"
    },
    "math.randomseed": {
        "body": "math.randomseed(${0:...})",
        "description": "math.randomseed (x)",
        "prefix": "math.randomseed"
    },
    "math.randomseed()": {
        "body": "math.randomseed()",
        "description": "把 x设为伪随机数发生器的“种子”： 相同的种子产生相同的随机数列。\r\n返回值：\r\n  无",
        "prefix": "math.randomseed()"
    },
    "math.sin": {
        "body": "math.sin( ${1:x} )",
        "description": "math.sin",
        "prefix": "math.sin"
    },
    "math.sin()": {
        "body": "math.sin()",
        "description": "计算x正弦值（假定参数是弧度）\r\n返回值：\r\n  返回 x 的正弦值",
        "prefix": "math.sin()"
    },
    "math.sinh": {
        "body": "math.sinh(${0:...})",
        "description": "math.sinh (x)",
        "prefix": "math.sinh"
    },
    "math.sqrt": {
        "body": "math.sqrt( ${1:x} )",
        "description": "math.sqrt",
        "prefix": "math.sqrt"
    },
    "math.sqrt()": {
        "body": "math.sqrt()",
        "description": "计算x平方根\r\n返回值：\r\n  返回 x 的平方根。",
        "prefix": "math.sqrt()"
    },
    "math.tan": {
        "body": "math.tan( ${1:x} )",
        "description": "math.tan",
        "prefix": "math.tan"
    },
    "math.tan()": {
        "body": "math.tan()",
        "description": "计算 x 的正切值，（假定参数是弧度）\r\n返回值：\r\n  返回 x 的正切值",
        "prefix": "math.tan()"
    },
    "math.tanh": {
        "body": "math.tanh(${0:...})",
        "description": "math.tanh (x)",
        "prefix": "math.tanh"
    },
    "math.tointeger": {
        "body": "math.tointeger( ${1:x} )",
        "description": "math.tointeger",
        "prefix": "math.tointeger"
    },
    "math.tointeger()": {
        "body": "math.tointeger()",
        "description": "将参数转换为整数\r\n返回值：\r\n  如果 x可以转换为一个整数， 返回该整数。 否则返回 nil。",
        "prefix": "math.tointeger()"
    },
    "math.type": {
        "body": "math.type( ${1:x} )",
        "description": "math.type",
        "prefix": "math.type"
    },
    "math.type()": {
        "body": "math.type()",
        "description": "判断数字类型\r\n返回值：\r\n  如果 x 是整数，返回 \"integer\"， 如果它是浮点数，返回 \"float\"， 如果 x 不是数字，返回 nil。",
        "prefix": "math.type()"
    },
    "math.ult": {
        "body": "math.ult(${0:...})",
        "description": "math.ult (m, n)",
        "prefix": "math.ult"
    },
    "math.ult()": {
        "body": "math.ult()",
        "description": "数值比较\r\n返回值：\r\n  整数 m 和 n 以无符号整数形式比较， m 在 n 之下，返回布尔真否则返回假。",
        "prefix": "math.ult()"
    },
    "misc.closePwm(id)": {
        "body": "misc.closePwm(${1:id})",
        "description": "关闭PWM\r\n返回值：\r\nnil",
        "prefix": "misc.closePwm(id)"
    },
    "misc.getCalib()": {
        "body": "misc.getCalib()",
        "description": "获取校准标志\r\n返回值：\r\nbool calib, true表示已校准，false或者nil表示未校准\r\n例子：\r\ncalib = misc.getCalib()\r\n",
        "prefix": "misc.getCalib()"
    },
    "misc.getClock()": {
        "body": "misc.getClock()",
        "description": "获取系统时间\r\n返回值：\r\ntable time,{year=2017,month=2,day=14,hour=14,min=19,sec=23}\r\n例子：\r\ntime = getClock()\r\n",
        "prefix": "misc.getClock()"
    },
    "misc.getImei()": {
        "body": "misc.getImei()",
        "description": "获取模块IMEI\r\n返回值：\r\nstring,IMEI号，如果未获取到返回\"\"\r\n注意：开机lua脚本运行之后，会发送at命令去查询imei，所以需要一定时间才能获取到imei。开机后立即调用此接口，基本上返回\"\"\r\n例子：\r\nimei = misc.getImei()\r\n",
        "prefix": "misc.getImei()"
    },
    "misc.getMuid()": {
        "body": "misc.getMuid()",
        "description": "获取模块MUID\r\n返回值：\r\nstring,MUID号，如果未获取到返回\"\"\r\n注意：开机lua脚本运行之后，会发送at命令去查询muid，所以需要一定时间才能获取到muid。开机后立即调用此接口，基本上返回\"\"\r\n例子：\r\nmuid = misc.getMuid()\r\n",
        "prefix": "misc.getMuid()"
    },
    "misc.getSn()": {
        "body": "misc.getSn()",
        "description": "获取模块序列号\r\n返回值：\r\nstring sn,序列号，如果未获取到返回\"\"\r\n注意：开机lua脚本运行之后，会发送at命令去查询sn，所以需要一定时间才能获取到sn。开机后立即调用此接口，基本上返回\"\"\r\n例子：\r\nsn = misc.getSn()\r\n",
        "prefix": "misc.getSn()"
    },
    "misc.getVbatt()": {
        "body": "misc.getVbatt()",
        "description": "获取VBAT的电池电压\r\n返回值：\r\nnumber,电池电压,单位mv\r\n例子：\r\nvb = getVbatt()\r\n",
        "prefix": "misc.getVbatt()"
    },
    "misc.getWeek()": {
        "body": "misc.getWeek()",
        "description": "获取星期\r\n返回值：\r\nnumber week，1-7分别对应周一到周日\r\n例子：\r\nweek = misc.getWeek()\r\n",
        "prefix": "misc.getWeek()"
    },
    "misc.openPwm(id, period, level)": {
        "body": "misc.openPwm(${1:id},${2: period},${3: level})",
        "description": "打开并且配置PWM(支持2路PWM，仅支持输出)\r\n返回值：\r\nnil",
        "prefix": "misc.openPwm(id, period, level)"
    },
    "misc.setClock(t, cbFnc)": {
        "body": "misc.setClock(${1:t},${2: cbFnc})",
        "description": "设置系统时间\r\n返回值：\r\nnil\r\n例子：\r\nmisc.setClock({year=2017,month=2,day=14,hour=14,min=2,sec=58})\r\n",
        "prefix": "misc.setClock(t, cbFnc)"
    },
    "misc.setImei(s, cbFnc)": {
        "body": "misc.setImei(${1:s},${2: cbFnc})",
        "description": "设置IMEI\r\n返回值：\r\nnil\r\n例子：\r\nmisc.setImei(”359759002514931”)\r\n",
        "prefix": "misc.setImei(s, cbFnc)"
    },
    "misc.setSn(s, cbFnc)": {
        "body": "misc.setSn(${1:s},${2: cbFnc})",
        "description": "设置SN\r\n返回值：\r\nnil\r\n例子：\r\nmisc.setSn(\"1234567890\")\r\nmisc.setSn(\"1234567890\",cbFnc)\r\n",
        "prefix": "misc.setSn(s, cbFnc)"
    },
    "module": {
        "body": "module(${0:...})",
        "description": "module (name [, ...])",
        "prefix": "module"
    },
    "mqtt.client(clientId, keepAlive, username, password, cleanSession, will, version)": {
        "body": "mqtt.client(${1:clientId},${2: keepAlive},${3: username},${4: password},${5: cleanSession},${6: will},${7: version})",
        "description": "创建一个mqtt client实例\r\n返回值：\r\ntable mqttc client实例\r\n例子：\r\nmqttc = mqtt.client(\"clientid-123\")\r\nmqttc = mqtt.client(\"clientid-123\",200)\r\nmqttc = mqtt.client(\"clientid-123\",nil,\"user\",\"password\")\r\nmqttc = mqtt.client(\"clientid-123\",nil,\"user\",\"password\",nil,nil,\"3.1\")\r\n",
        "prefix": "mqtt.client(clientId, keepAlive, username, password, cleanSession, will, version)"
    },
    "mqttc:connect(host, port, transport, cert, timeout)": {
        "body": "mqttc:connect(${1:host},${2: port},${3: transport},${4: cert},${5: timeout})",
        "description": "连接mqtt服务器\r\n返回值：\r\nresult true表示成功，false或者nil表示失败\r\n例子：\r\nmqttc = mqtt.client(\"clientid-123\", nil, nil, false); mqttc:connect(\"mqttserver.com\", 1883, \"tcp\", 5)\r\n",
        "prefix": "mqttc:connect(host, port, transport, cert, timeout)"
    },
    "mqttc:disconnect()": {
        "body": "mqttc:disconnect()",
        "description": "断开与服务器的连接\r\n返回值：\r\nnil\r\n例子：\r\nmqttc = mqtt.client(\"clientid-123\", nil, nil, false)\r\nmqttc:connect(\"mqttserver.com\", 1883, \"tcp\")\r\nprocess data\r\nmqttc:disconnect()\r\n",
        "prefix": "mqttc:disconnect()"
    },
    "mqttc:publish(topic, payload, qos, retain)": {
        "body": "mqttc:publish(${1:topic},${2: payload},${3: qos},${4: retain})",
        "description": "发布一条消息\r\n返回值：\r\nbool 发布成功返回true，失败返回false\r\n例子：\r\nmqttc = mqtt.client(\"clientid-123\", nil, nil, false)\r\nmqttc:connect(\"mqttserver.com\", 1883, \"tcp\")\r\nmqttc:publish(\"/topic\", \"publish from luat mqtt client\", 0)\r\n",
        "prefix": "mqttc:publish(topic, payload, qos, retain)"
    },
    "mqttc:receive(timeout, msg)": {
        "body": "mqttc:receive(${1:timeout},${2: msg})",
        "description": "接收消息\r\n返回值：\r\nresult 数据接收结果，true表示成功，false表示失败\r\n例子：\r\ntrue, packet = mqttc:receive(2000)\r\nfalse, error_message = mqttc:receive(2000)\r\nfalse, msg, para = mqttc:receive(2000)\r\n",
        "prefix": "mqttc:receive(timeout, msg)"
    },
    "mqttc:subscribe(topic, qos)": {
        "body": "mqttc:subscribe(${1:topic},${2: qos})",
        "description": "订阅主题\r\n返回值：\r\nbool true表示成功，false或者nil表示失败\r\n例子：\r\nmqttc:subscribe(\"/abc\", 0) -- subscribe topic \"/abc\" with qos = 0\r\nmqttc:subscribe({[\"/topic1\"] = 0, [\"/topic2\"] = 1, [\"/topic3\"] = 2}) -- subscribe multi topic\r\n",
        "prefix": "mqttc:subscribe(topic, qos)"
    },
    "mqttc:unsubscribe(topic)": {
        "body": "mqttc:unsubscribe(${1:topic})",
        "description": "取消订阅主题\r\n返回值：\r\nbool true表示成功，false或者nil表示失败\r\n例子：\r\nmqttc:unsubscribe(\"/abc\") -- unsubscribe topic \"/abc\"\r\nmqttc:unsubscribe({\"/topic1\", \"/topic2\", \"/topic3\"}) -- unsubscribe multi topic\r\n",
        "prefix": "mqttc:unsubscribe(topic)"
    },
    "mt:asyncRecv()": {
        "body": "mt:asyncRecv()",
        "description": "异步接收数据\r\n返回值：\r\nnil, 表示没有收到数据\r\n例子：\r\nc = socket.tcp(); c:connect()\r\ndata = c:asyncRecv()\r\n",
        "prefix": "mt:asyncRecv()"
    },
    "mt:asyncSelect(keepAlive, pingreq)": {
        "body": "mt:asyncSelect(${1:keepAlive},${2: pingreq})",
        "description": "异步收发选择器\r\n返回值：\r\nboole,false 失败，true 表示成功",
        "prefix": "mt:asyncSelect(keepAlive, pingreq)"
    },
    "mt:asyncSend(data)": {
        "body": "mt:asyncSend(${1:data})",
        "description": "异步发送数据\r\n返回值：\r\nresult true - 成功，false - 失败\r\n例子：\r\nc = socket.tcp(); c:connect(); c:asyncSend(\"12345678\");\r\n",
        "prefix": "mt:asyncSend(data)"
    },
    "mt:close(slow)": {
        "body": "mt:close(${1:slow})",
        "description": "销毁一个socket\r\n返回值：\r\nnil\r\n例子：\r\nc = socket.tcp(); c:connect(); c:send(\"123\"); c:close()\r\n",
        "prefix": "mt:close(slow)"
    },
    "mt:connect(address, port, timeout)": {
        "body": "mt:connect(${1:address},${2: port},${3: timeout})",
        "description": "连接服务器\r\n返回值：\r\nbool result true - 成功，false - 失败\r\n@number timeout, 链接服务器最长超时时间\r\n例子：\r\nc = socket.tcp(); c:connect(\"www.baidu.com\",80,5);\r\n",
        "prefix": "mt:connect(address, port, timeout)"
    },
    "mt:recv(timeout, msg, msgNoResume)": {
        "body": "mt:recv(${1:timeout},${2: msg},${3: msgNoResume})",
        "description": "接收数据\r\n返回值：\r\nresult 数据接收结果，true表示成功，false表示失败\r\n例子：\r\nc = socket.tcp(); c:connect()\r\nresult, data = c:recv()\r\nfalse,msg,param = c:recv(60000,\"publish_msg\")\r\n",
        "prefix": "mt:recv(timeout, msg, msgNoResume)"
    },
    "mt:send(data)": {
        "body": "mt:send(${1:data})",
        "description": "发送数据\r\n返回值：\r\nresult true - 成功，false - 失败\r\n例子：\r\nc = socket.tcp(); c:connect(); c:send(\"12345678\");\r\n",
        "prefix": "mt:send(data)"
    },
    "net.cengQueryPoll(period)": {
        "body": "net.cengQueryPoll(${1:period})",
        "description": "发起查询基站信息(当前和临近小区信息)的请求\r\n返回值：\r\nbool result, true:查询成功，false:查询失败\r\n例子：\r\nnet.cengQueryPoll() --查询1次\r\nnet.cengQueryPoll(60000) --每分钟查询1次\r\n",
        "prefix": "net.cengQueryPoll(period)"
    },
    "net.csqQueryPoll(period)": {
        "body": "net.csqQueryPoll(${1:period})",
        "description": "发起查询信号强度的请求\r\n返回值：\r\nbool , true:查询成功，false:查询停止\r\n例子：\r\nnet.csqQueryPoll() --查询1次\r\nnet.csqQueryPoll(60000) --每分钟查询1次\r\n",
        "prefix": "net.csqQueryPoll(period)"
    },
    "net.getCellInfo()": {
        "body": "net.getCellInfo()",
        "description": "获取当前和临近位置区、小区以及信号强度的拼接字符串\r\n返回值：\r\nstring cellInfo,当前和临近位置区、小区以及信号强度的拼接字符串，例如：\"6311.49234.30;6311.49233.23;6322.49232.18;\"\r\n例子：\r\nnet.getCellInfo()\r\n",
        "prefix": "net.getCellInfo()"
    },
    "net.getCellInfoExt(dbm)": {
        "body": "net.getCellInfoExt(${1:dbm})",
        "description": "获取当前和临近位置区、小区、mcc、mnc、以及信号强度的拼接字符串\r\n返回值：\r\nstring cellInfo,当前和临近位置区、小区、mcc、mnc、以及信号强度的拼接字符串，例如：\"460.01.6311.49234.30;460.01.6311.49233.23;460.02.6322.49232.18;\"\r\n例子：\r\nnet.getCellInfoExt()\r\n",
        "prefix": "net.getCellInfoExt(dbm)"
    },
    "net.getCi()": {
        "body": "net.getCi()",
        "description": "获取当前小区ID\r\n返回值：\r\nstring ci,当前小区ID(16进制字符串，例如\"93e1\")，如果还没有注册GSM网络，则返回\"\"\r\n例子：\r\nnet.getCi()\r\n",
        "prefix": "net.getCi()"
    },
    "net.getLac()": {
        "body": "net.getLac()",
        "description": "获取当前位置区ID\r\n返回值：\r\nstring lac,当前位置区ID(16进制字符串，例如\"18be\")，如果还没有注册GSM网络，则返回\"\"\r\n例子：\r\nnet.getLac()\r\n",
        "prefix": "net.getLac()"
    },
    "net.getMcc()": {
        "body": "net.getMcc()",
        "description": "获取当前小区的mcc\r\n返回值：\r\nstring mcc,当前小区的mcc，如果还没有注册GSM网络，则返回sim卡的mcc\r\n例子：\r\nnet.getMcc()\r\n",
        "prefix": "net.getMcc()"
    },
    "net.getMnc()": {
        "body": "net.getMnc()",
        "description": "获取当前小区的mnc\r\n返回值：\r\nstring mcn,当前小区的mnc，如果还没有注册GSM网络，则返回sim卡的mnc\r\n例子：\r\nnet.getMnc()\r\n",
        "prefix": "net.getMnc()"
    },
    "net.getMultiCell(cbFnc)": {
        "body": "net.getMultiCell(${1:cbFnc})",
        "description": "实时读取“当前和临近小区信息”\r\n返回值：\r\nnil",
        "prefix": "net.getMultiCell(cbFnc)"
    },
    "net.getRssi()": {
        "body": "net.getRssi()",
        "description": "获取信号强度\r\n返回值：\r\nnumber rssi,当前信号强度(取值范围0-31)\r\n例子：\r\nnet.getRssi()\r\n",
        "prefix": "net.getRssi()"
    },
    "net.getState()": {
        "body": "net.getState()",
        "description": "获取GSM网络注册状态\r\n返回值：\r\nstring state,GSM网络注册状态，\r\n\"INIT\"表示正在初始化\r\n\"REGISTERED\"表示已注册\r\n\"UNREGISTER\"表示未注册\r\n例子：\r\nnet.getState()\r\n",
        "prefix": "net.getState()"
    },
    "net.getTa()": {
        "body": "net.getTa()",
        "description": "获取TA值\r\n返回值：\r\nnumber ta,TA值\r\n例子：\r\nnet.getTa()\r\n",
        "prefix": "net.getTa()"
    },
    "net.startQueryAll(...)": {
        "body": "net.startQueryAll(${1:...})",
        "description": "设置查询信号强度和基站信息的间隔\r\n返回值：\r\nbool ，true：设置成功，false：设置失败\r\n例子：\r\nnet.startQueryAll()\r\nnet.startQueryAll(60000) -- 1分钟查询1次信号强度，只立即查询1次基站信息\r\nnet.startQueryAll(60000,600000) -- 1分钟查询1次信号强度，10分钟查询1次基站信息\r\n",
        "prefix": "net.startQueryAll(...)"
    },
    "net.stopQueryAll()": {
        "body": "net.stopQueryAll()",
        "description": "停止查询信号强度和基站信息\r\n返回值：\r\n无\r\n例子：\r\nnet.stopQueryAll()\r\n",
        "prefix": "net.stopQueryAll()"
    },
    "net.switchFly(mode)": {
        "body": "net.switchFly(${1:mode})",
        "description": "设置飞行模式\r\n返回值：\r\nnil\r\n例子：\r\nnet.switchFly(mode)\r\n",
        "prefix": "net.switchFly(mode)"
    },
    "netLed.setup(flag, pin)": {
        "body": "netLed.setup(${1:flag},${2: pin})",
        "description": "配置网络指示灯并且立即执行配置后的动作\r\n返回值：\r\nnil\r\n例子：\r\nsetup(true,pio.P1_1)表示打开网络指示灯功能，GPIO33控制指示灯\r\nsetup(false)表示关闭网络指示灯功能\r\n",
        "prefix": "netLed.setup(flag, pin)"
    },
    "netLed.updateBlinkTime(state, on, off)": {
        "body": "netLed.updateBlinkTime(${1:state},${2: on},${3: off})",
        "description": "配置某种工作状态下指示灯点亮和熄灭的时长（如果用户不配置，使用netLed.lua中ledBlinkTime配置的默认值）\r\n返回值：\r\nnil\r\n例子：\r\nupdateBlinkTime(\"FLYMODE\",1000,500)表示飞行模式工作状态下，指示灯闪烁规律为：亮1秒，灭0.5秒\r\nupdateBlinkTime(\"SCK\",0xFFFF,0)表示有socket连接上后台的工作状态下，指示灯闪烁规律为：常亮\r\nupdateBlinkTime(\"SIMERR\",0,0xFFFF)表示SIM卡异常状态下，指示灯闪烁规律为：常灭\r\n",
        "prefix": "netLed.updateBlinkTime(state, on, off)"
    },
    "next": {
        "body": "next(${1:table}${2:[, index]})",
        "description": "next (table [, index])",
        "prefix": "next"
    },
    "ntp.getServers()": {
        "body": "ntp.getServers()",
        "description": "获取NTP服务器地址列表\r\n返回值：\r\ntable,服务器地址列表\r\n例子：\r\nlocal addtable = ntp.getServers()\r\n",
        "prefix": "ntp.getServers()"
    },
    "ntp.isEnd()": {
        "body": "ntp.isEnd()",
        "description": "NTP同步标志\r\n返回值：\r\nboole,NTP的同步状态true为成功,fasle为失败\r\n例子：\r\nlocal sta = ntp.isEnd()\r\n",
        "prefix": "ntp.isEnd()"
    },
    "ntp.ntpTime(ts, fnc, fun)": {
        "body": "ntp.ntpTime(${1:ts},${2: fnc},${3: fun})",
        "description": "同步时间，每个NTP服务器尝试3次，超时8秒,适用于被任务函数调用\r\n返回值：\r\n无\r\n例子：\r\nntp.ntpTime() -- 只同步1次\r\nntp.ntpTime(1) -- 1小时同步1次\r\nntp.ntpTime(nil,fnc) -- 只同步1次，同步成功后执行fnc()\r\nntp.ntpTime(24,fnc) -- 24小时同步1次，同步成功后执行fnc()\r\n",
        "prefix": "ntp.ntpTime(ts, fnc, fun)"
    },
    "ntp.setServers(st)": {
        "body": "ntp.setServers(${1:st})",
        "description": "设置NTP服务器地址列表\r\n返回值：\r\n无\r\n例子：\r\nntp.getServers({\"1edu.ntp.org.cn\",\"cn.ntp.org.cn\"})\r\n",
        "prefix": "ntp.setServers(st)"
    },
    "ntp.timeSync(ts, fnc, fun)": {
        "body": "ntp.timeSync(${1:ts},${2: fnc},${3: fun})",
        "description": "自动同步时间任务适合独立执行.\r\n返回值：\r\n无\r\n例子：\r\nntp.timeSync() -- 只同步1次\r\nntp.timeSync(1) -- 1小时同步1次\r\nntp.timeSync(nil,fnc) -- 只同步1次，同步成功后执行fnc()\r\nntp.timeSync(24,fnc) -- 24小时同步1次，同步成功后执行fnc()\r\n",
        "prefix": "ntp.timeSync(ts, fnc, fun)"
    },
    "nvm.flush()": {
        "body": "nvm.flush()",
        "description": "所有参数立即写入文件系统\r\n返回值：\r\nnil\r\n例子：\r\nnvm.flush()\r\n",
        "prefix": "nvm.flush()"
    },
    "nvm.get(k)": {
        "body": "nvm.get(${1:k})",
        "description": "读取某个参数的值\r\n返回值：\r\n参数值\r\n例子：\r\nnameValue = nvm.get(\"name\")\r\n",
        "prefix": "nvm.get(k)"
    },
    "nvm.gett(k, kk)": {
        "body": "nvm.gett(${1:k},${2: kk})",
        "description": "读取某个table类型参数的某一个索引的值\r\n返回值：\r\n无\r\n例子：\r\nnvm.gett(\"score\",\"chinese\")\r\n",
        "prefix": "nvm.gett(k, kk)"
    },
    "nvm.init(defaultCfgFile)": {
        "body": "nvm.init(${1:defaultCfgFile})",
        "description": "初始化参数存储模块\r\n返回值：\r\nnil\r\n例子：\r\nnvm.init(\"config.lua\")\r\n",
        "prefix": "nvm.init(defaultCfgFile)"
    },
    "nvm.remove()": {
        "body": "nvm.remove()",
        "description": "请求删除参数文件.\r\n返回值：\r\nnil\r\n例子：\r\nnvm.remove()\r\n",
        "prefix": "nvm.remove()"
    },
    "nvm.restore()": {
        "body": "nvm.restore()",
        "description": "参数恢复出厂设置\r\n返回值：\r\nnil\r\n例子：\r\nnvm.restore()\r\n",
        "prefix": "nvm.restore()"
    },
    "nvm.set(k, v, r, s)": {
        "body": "nvm.set(${1:k},${2: v},${3: r},${4: s})",
        "description": "设置某个参数的值\r\n返回值：\r\nbool或者nil，成功返回true，失败返回nil\r\n例子：\r\nnvm.set(\"name\",\"Luat\")，参数name赋值为Luat，立即写入文件系统\r\nnvm.set(\"age\",12,\"SVR\")，参数age赋值为12，立即写入文件系统，如果旧值不是12，会产生一个PARA_CHANGED_IND消息，携带 \"age\",12,\"SVR\" 3个参数\r\nnvm.set(\"class\",\"Class2\",nil,false)，参数class赋值为Class2，不写入文件系统\r\nnvm.set(\"score\",{chinese=100,math=99,english=98})，参数score赋值为{chinese=100,math=99,english=98}，立即写入文件系统\r\n",
        "prefix": "nvm.set(k, v, r, s)"
    },
    "nvm.sett(k, kk, v, r, s)": {
        "body": "nvm.sett(${1:k},${2: kk},${3: v},${4: r},${5: s})",
        "description": "设置某个table类型参数的某一个索引的值\r\n返回值：\r\nbool或者nil，成功返回true，失败返回nil\r\n例子：\r\nnvm.sett(\"score\",\"chinese\",100)，参数score[\"chinese\"]赋值为100，立即写入文件系统\r\nnvm.sett(\"score\",\"chinese\",100,\"SVR\")，参数score[\"chinese\"]赋值为100，立即写入文件系统，\r\n-- 如果旧值不是100，会产生一个TPARA_CHANGED_IND消息，携带 \"score\",\"chinese\",100,\"SVR\" 4个参数\r\nnvm.sett(\"score\",\"chinese\",100,nil,false)，参数class赋值为Class2，不写入文件系统\r\n",
        "prefix": "nvm.sett(k, kk, v, r, s)"
    },
    "os.clock": {
        "body": "os.clock(${0:...})",
        "description": "os.clock ()",
        "prefix": "os.clock"
    },
    "os.date": {
        "body": "os.date(${0:...})",
        "description": "os.date ([format [, time]])",
        "prefix": "os.date"
    },
    "os.difftime": {
        "body": "os.difftime(${0:...})",
        "description": "os.difftime (t2, t1)",
        "prefix": "os.difftime"
    },
    "os.execute": {
        "body": "os.execute(${0:...})",
        "description": "os.execute ([command])",
        "prefix": "os.execute"
    },
    "os.exit": {
        "body": "os.exit(${0:...})",
        "description": "os.exit ([code])",
        "prefix": "os.exit"
    },
    "os.getenv": {
        "body": "os.getenv(${0:...})",
        "description": "os.getenv (varname)",
        "prefix": "os.getenv"
    },
    "os.remove": {
        "body": "os.remove(${0:...})",
        "description": "os.remove (filename)",
        "prefix": "os.remove"
    },
    "os.rename": {
        "body": "os.rename(${0:...})",
        "description": "os.rename (oldname, newname)",
        "prefix": "os.rename"
    },
    "os.setlocale": {
        "body": "os.setlocale(${0:...})",
        "description": "os.setlocale (locale [, category])",
        "prefix": "os.setlocale"
    },
    "os.time": {
        "body": "os.time(${0:...})",
        "description": "os.time ([table])",
        "prefix": "os.time"
    },
    "os.tmpname": {
        "body": "os.tmpname(${0:...})",
        "description": "os.tmpname ()",
        "prefix": "os.tmpname"
    },
    "pack.pack()": {
        "body": "pack.pack()",
        "description": "打包字符串的值,在pack的时候有符号 无符号的输出结果都是一样的 unpack时有符号跟无符号才有区别\r\n返回值：\r\n  一个包含所有格式化变量的字符串\r\n例子：\r\nprint(\"pcak.pack test：\")\r\nprint(pack.pack(\"A\",10))--当\"10\"以字符串形式包装时，会打印出“10”\r\nprint(common.binstohexs(pack.pack(\"b\",0x10)))--将0x01以十六进制打包为字符串，然后用十六进制输出0x10\r\nprint(pack.pack(\"A\",\"LUAT\"))\r\n",
        "prefix": "pack.pack()"
    },
    "pack.unpack()": {
        "body": "pack.unpack()",
        "description": "解包字符串\r\n返回值：\r\n  nextpos,字符串标记的位置\r\nval1,第一个解包的值\r\nval2,第二个解包的值\r\nvaln,第n个解包的值\r\n例子：\r\nprint(\"pack.unpack test:\")\r\nnextpox1,val1,val2,val3,val4=pack.unpack(\"luat100\",\"c4\")--\"nextpos\"下个待解析的位置\t，取4个字符(char)\r\nprint(nextpox1,val1,val2,val3,val4)        --分别对应的是\"5\"，l\",\"u\",\"a\",\"t\"的ascii码数据\r\nprint(string.char(val1,val2,val3,val4))    --将ascii码数据转化为字符输出\r\nnextpox2,string1=pack.unpack(\"luat100\",\"A4\")--输出“luat”\r\nprint(nextpox2,string1)--输出5 luat\r\nnextpox3,number1,number2=pack.unpack(common.hexstobins(\"006400000064\"),\">H>i\")--[[输出无符号短型和整形,因为无符号短型是2个字节，整形是4个字节,输出为100,100--]]\r\nprint(nextpox3,number1,number2)--输出7 100 100\r\nnextpox3,number1=pack.unpack(common.hexstobins(\"0064\"),\">h\")--输出为100，因为短型是2个字节\r\nprint(nextpox3,number1)--输出3 100\r\n",
        "prefix": "pack.unpack()"
    },
    "package.config": {
        "body": "package.config(${0:...})",
        "description": "package.config",
        "prefix": "package.config"
    },
    "package.cpath": {
        "body": "package.cpath(${0:...})",
        "description": "package.cpath",
        "prefix": "package.cpath"
    },
    "package.loaded": {
        "body": "package.loaded(${0:...})",
        "description": "package.loaded",
        "prefix": "package.loaded"
    },
    "package.loaders": {
        "body": "package.loaders(${0:...})",
        "description": "package.loaders",
        "prefix": "package.loaders"
    },
    "package.loadlib": {
        "body": "package.loadlib(${0:...})",
        "description": "package.loadlib (libname, funcname)",
        "prefix": "package.loadlib"
    },
    "package.path": {
        "body": "package.path(${0:...})",
        "description": "package.path",
        "prefix": "package.path"
    },
    "package.preload": {
        "body": "package.preload(${0:...})",
        "description": "package.preload",
        "prefix": "package.preload"
    },
    "package.searchers": {
        "body": "package.searchers(${0:...})",
        "description": "package.searchers",
        "prefix": "package.searchers"
    },
    "package.searchpath": {
        "body": "package.searchpath(${0:...})",
        "description": "package.searchpath (name, path [, sep [, rep]])",
        "prefix": "package.searchpath"
    },
    "package.seeall": {
        "body": "package.seeall(${0:...})",
        "description": "package.seeall (module)",
        "prefix": "package.seeall"
    },
    "pairs": {
        "body": "pairs(${0:...})",
        "description": "pairs (t)",
        "prefix": "pairs"
    },
    "patch.safeJsonDecode(s) (local函数 无法被外部调用)": {
        "body": "patch.safeJsonDecode(${1:s) (local函数 无法被外部调用})",
        "description": "封装自定义的json.decode接口\r\n返回值：\r\ntable,第一个返回值为解析json字符串后的table",
        "prefix": "patch.safeJsonDecode(s) (local函数 无法被外部调用)"
    },
    "pb.delete(index, cb)": {
        "body": "pb.delete(${1:index},${2: cb})",
        "description": "删除一条电话本记录\r\n返回值：\r\n无\r\n例子：\r\npb.delete(1,cb)\r\n",
        "prefix": "pb.delete(index, cb)"
    },
    "pb.read(index, cb)": {
        "body": "pb.read(${1:index},${2: cb})",
        "description": "读取一条电话本记录\r\n返回值：\r\n无\r\n例子：\r\npb.read(1,cb)\r\n",
        "prefix": "pb.read(index, cb)"
    },
    "pb.setStorage(storage, cb)": {
        "body": "pb.setStorage(${1:storage},${2: cb})",
        "description": "设置电话本存储区域\r\n返回值：\r\n无\r\n例子：\r\npb.setStorage(storage,cb)\r\n",
        "prefix": "pb.setStorage(storage, cb)"
    },
    "pb.write(index, name, num, cb)": {
        "body": "pb.write(${1:index},${2: name},${3: num},${4: cb})",
        "description": "写入一条电话本记录\r\n返回值：\r\n无\r\n例子：\r\npb.write(1,\"zhangsan\",\"13233334444\",cb)\r\n",
        "prefix": "pb.write(index, name, num, cb)"
    },
    "pcall": {
        "body": "pcall(${0:...})",
        "description": "pcall (f, arg1, ...)",
        "prefix": "pcall"
    },
    "pins.close(pin)": {
        "body": "pins.close(${1:pin})",
        "description": "关闭GPIO模式\r\n返回值：\r\n无\r\n例子：\r\npins.close(pio.P1_1)，关闭GPIO33\r\n",
        "prefix": "pins.close(pin)"
    },
    "pins.setup(pin, val, pull)": {
        "body": "pins.setup(${1:pin},${2: val},${3: pull})",
        "description": "配置GPIO模式\r\n返回值：\r\nfunction\r\n配置为输出模式时，返回的函数，可以设置IO的电平\r\n配置为输入或者中断模式时，返回的函数，可以实时获取IO的电平\r\n例子：\r\nsetOutputFnc = pins.setup(pio.P1_1,0)，配置GPIO 33，输出模式，默认输出低电平；\r\n-- 执行setOutputFnc(0)可输出低电平，执行setOutputFnc(1)可输出高电平\r\ngetInputFnc = pins.setup(pio.P1_1,intFnc)，配置GPIO33，中断模式\r\n-- 产生中断时自动调用intFnc(msg)函数：上升沿中断时：msg为cpu.INT_GPIO_POSEDGE；下降沿中断时：msg为cpu.INT_GPIO_NEGEDGE\r\n-- 执行getInputFnc()即可获得当前电平；如果是低电平，getInputFnc()返回0；如果是高电平，getInputFnc()返回1\r\ngetInputFnc = pins.setup(pio.P1_1),配置GPIO33，输入模式\r\n-- 执行getInputFnc()即可获得当前电平；如果是低电平，getInputFnc()返回0；如果是高电平，getInputFnc()返回1\r\n",
        "prefix": "pins.setup(pin, val, pull)"
    },
    "pio.pin.getval()": {
        "body": "pio.pin.getval()",
        "description": "读取管脚的值\r\n返回值：\r\n  number类型，0表示低电平，1表示高电平",
        "prefix": "pio.pin.getval()"
    },
    "pio.pin.setdebounce()": {
        "body": "pio.pin.setdebounce()",
        "description": "配置IO口消抖时间\r\n返回值：\r\n  无\r\n例子：\r\npio.pin.setdebounce(20)  --延时消抖设置为20ms\r\npio.pin.setdebounce(5)  --延时消抖设置为5ms\r\npio.pin.setdebounce(0)  --关闭延时消抖功能\r\n",
        "prefix": "pio.pin.setdebounce()"
    },
    "pio.pin.setdir()": {
        "body": "pio.pin.setdir()",
        "description": "设置管脚的描述\r\n返回值：\r\n  无",
        "prefix": "pio.pin.setdir()"
    },
    "pio.pin.sethigh()": {
        "body": "pio.pin.sethigh()",
        "description": "设置管脚为高电平(1)\r\n返回值：\r\n  无",
        "prefix": "pio.pin.sethigh()"
    },
    "pio.pin.setlow()": {
        "body": "pio.pin.setlow()",
        "description": "设置管脚为低电平(0)\r\n返回值：\r\n  无",
        "prefix": "pio.pin.setlow()"
    },
    "pio.pin.setpull()": {
        "body": "pio.pin.setpull()",
        "description": "配置IO口默认状态\r\n返回值：\r\n  无\r\n例子：\r\npio.pin.setpull(pio.PULLUP,pio.P0_5)  --配置为上拉\r\n--pio.pin.setpull(pio.PULLDOWN,pio.P0_5)  --配置为下拉\r\n--pio.pin.setpull(pio.NOPULL,pio.P0_5)  --不配置上下拉\r\n",
        "prefix": "pio.pin.setpull()"
    },
    "pio.pin.setval()": {
        "body": "pio.pin.setval()",
        "description": "设置管脚的值\r\n返回值：\r\n  无",
        "prefix": "pio.pin.setval()"
    },
    "pm.isSleep(tag)": {
        "body": "pm.isSleep(${1:tag})",
        "description": "pm.isSleep([tag]) 读取某个Lua应用或者全局的休眠状态\r\n返回值：\r\ntrue休眠，其余没休眠\r\n例子：\r\npm.isSleep() -- 查询全局休眠状态\r\npm.isSleep('lcd') -- 查询lcd的休眠状态\r\n",
        "prefix": "pm.isSleep(tag)"
    },
    "pm.sleep(tag)": {
        "body": "pm.sleep(${1:tag})",
        "description": "某个Lua应用休眠系统\r\n返回值：\r\n无\r\n例子：\r\npm.sleep(tag)\r\n",
        "prefix": "pm.sleep(tag)"
    },
    "pm.wake(tag)": {
        "body": "pm.wake(${1:tag})",
        "description": "某个Lua应用唤醒系统\r\n返回值：\r\n无\r\n例子：\r\npm.wake(tag)\r\n",
        "prefix": "pm.wake(tag)"
    },
    "pmd.init()": {
        "body": "pmd.init()",
        "description": "设置电源管理参数 <br>\r\n返回值：\r\n  1:成功\r\n0:失败",
        "prefix": "pmd.init()"
    },
    "pmd.ldoset()": {
        "body": "pmd.ldoset()",
        "description": "ldo 控制\r\n返回值：\r\n  无\r\n例子：\r\n--GPIO8输出电平时，要求输出2.8V，则调用\r\npmd.ldoset(5,pmd.LDO_VMMC)\r\n",
        "prefix": "pmd.ldoset()"
    },
    "pmd.sleep()": {
        "body": "pmd.sleep()",
        "description": "省电控制\r\n返回值：\r\n  无",
        "prefix": "pmd.sleep()"
    },
    "powerKey.setup(longPrd, longCb, shortCb)": {
        "body": "powerKey.setup(${1:longPrd},${2: longCb},${3: shortCb})",
        "description": "配置开机键长按弹起和短按弹起的功能.\r\n返回值：\r\nnil\r\n例子：\r\npowerKey.setup(nil,longCb,shortCb)\r\npowerKey.setup(5000,longCb)\r\npowerKey.setup()\r\n",
        "prefix": "powerKey.setup(longPrd, longCb, shortCb)"
    },
    "print": {
        "body": "print(${1:...})",
        "description": "print(...)",
        "prefix": "print"
    },
    "qrencode.encode ()": {
        "body": "qrencode.encode ()",
        "description": "创建二维码信息\r\n返回值：\r\n  width 生成的二维码信息宽度 \r\n\r\n例子：\r\n local width, data = qrencode.encode(\"http://www.openluat.com\")\r\n",
        "prefix": "qrencode.encode ()"
    },
    "record.delete()": {
        "body": "record.delete()",
        "description": "删除录音\r\n返回值：\r\n无\r\n例子：\r\nrecord.delete()\r\n",
        "prefix": "record.delete()"
    },
    "record.exists()": {
        "body": "record.exists()",
        "description": "判断是否存在录音\r\n返回值：\r\nresult true - 有录音 false - 无录音\r\n例子：\r\nresult = record.exists()\r\n",
        "prefix": "record.exists()"
    },
    "record.getData(offset, len)": {
        "body": "record.getData(${1:offset},${2: len})",
        "description": "读取录音数据\r\n返回值：\r\ndata 录音数据\r\n例子：\r\ndata = record.getData(0, 1024)\r\n",
        "prefix": "record.getData(offset, len)"
    },
    "record.getFilePath()": {
        "body": "record.getFilePath()",
        "description": "读取录音文件的完整路径\r\n返回值：\r\nstring 录音文件的完整路径\r\n例子：\r\nfilePath = record.getFilePath()\r\n",
        "prefix": "record.getFilePath()"
    },
    "record.getSize()": {
        "body": "record.getSize()",
        "description": "读取录音文件总长度，录音时长\r\n返回值：\r\nfileSize 录音文件大小\r\n例子：\r\nfileSize, duration = record.getSize()\r\n",
        "prefix": "record.getSize()"
    },
    "record.isBusy()": {
        "body": "record.isBusy()",
        "description": "是否正在处理录音\r\n返回值：\r\nresult true - 正在处理 false - 空闲\r\n例子：\r\nresult = record.isBusy()\r\n",
        "prefix": "record.isBusy()"
    },
    "record.start(seconds, cb)": {
        "body": "record.start(${1:seconds},${2: cb})",
        "description": "开始录音\r\n返回值：\r\nresult true - 开始录音 其他 - 失败\r\n例子：\r\nresult = record.start()\r\n",
        "prefix": "record.start(seconds, cb)"
    },
    "record.stop(cbFnc)": {
        "body": "record.stop(${1:cbFnc})",
        "description": "停止录音\r\n返回值：\r\n无\r\n例子：\r\nrecord.stop(cb)\r\n",
        "prefix": "record.stop(cbFnc)"
    },
    "require": {
        "body": "require\"${1:module}\"",
        "description": "require()",
        "prefix": "require"
    },
    "ret": {
        "body": "return ${1:...}",
        "description": "return ...",
        "prefix": "ret"
    },
    "ril.deRegUrc(prefix)": {
        "body": "ril.deRegUrc(${1:prefix})",
        "description": "解注册某个urc的处理函数\r\n返回值：\r\n无\r\n例子：\r\ndeRegUrc(\"+CREG\")\r\n",
        "prefix": "ril.deRegUrc(prefix)"
    },
    "ril.regRsp(head, fnc, typ, formt)": {
        "body": "ril.regRsp(${1:head},${2: fnc},${3: typ},${4: formt})",
        "description": "注册某个AT命令应答的处理函数\r\n返回值：\r\nbool ,成功返回true，失败false\r\n例子：\r\nril.regRsp(\"+CSQ\", rsp)\r\n",
        "prefix": "ril.regRsp(head, fnc, typ, formt)"
    },
    "ril.regUrc(prefix, handler)": {
        "body": "ril.regUrc(${1:prefix},${2: handler})",
        "description": "注册某个urc的处理函数\r\n返回值：\r\n无\r\n例子：\r\nril.regUrc(\"+CREG\", neturc)\r\n",
        "prefix": "ril.regUrc(prefix, handler)"
    },
    "ril.request(cmd, arg, onrsp, delay)": {
        "body": "ril.request(${1:cmd},${2: arg},${3: onrsp},${4: delay})",
        "description": "发送AT命令到底层软件\r\n返回值：\r\n无\r\n例子：\r\nril.request(\"AT+CENG=1,1\")\r\nril.request(\"AT+CRSM=214,28539,0,0,12,\\\"64f01064f03064f002fffff\\\"\", nil, crsmResponse)\r\n",
        "prefix": "ril.request(cmd, arg, onrsp, delay)"
    },
    "rtos.get_env_usage()": {
        "body": "rtos.get_env_usage()",
        "description": "获取 lua 任务消息队列的使用百分比\r\n返回值：\r\n  percentage，百分比，例如使用了 80%，则 percentage 为 80",
        "prefix": "rtos.get_env_usage()"
    },
    "rtos.get_fs_free_size()": {
        "body": "rtos.get_fs_free_size()",
        "description": "获取文件系统剩余空间\r\n返回值：\r\n  文件系统剩余空间，单位Bytes",
        "prefix": "rtos.get_fs_free_size()"
    },
    "rtos.make_dir()": {
        "body": "rtos.make_dir()",
        "description": "创建目录\r\n返回值：\r\n  布尔值\r\ntrue表示创建成功，false表示失败",
        "prefix": "rtos.make_dir()"
    },
    "rtos.on (id, handler)": {
        "body": "rtos.on (${1:id},${2: handler})",
        "description": "注册rtos消息回调处理函数\r\n返回值：\r\n无\r\n例子：\r\nrtos.on(rtos.MSG_KEYPAD, function(param) handle keypad message end)\r\n",
        "prefix": "rtos.on (id, handler)"
    },
    "rtos.poweroff()": {
        "body": "rtos.poweroff()",
        "description": "软件关机\r\n返回值：\r\n  无",
        "prefix": "rtos.poweroff()"
    },
    "rtos.poweron()": {
        "body": "rtos.poweron()",
        "description": "是否启动 GSM 开机\r\n返回值：\r\n  无",
        "prefix": "rtos.poweron()"
    },
    "rtos.poweron_reason()": {
        "body": "rtos.poweron_reason()",
        "description": "读取开机原因值\r\n返回值：\r\n  rtos. POWERON_KEY(=0),按键开机\r\nrtos. POWERON_CHARGER(=1),充电开机\r\nrtos. POWERON_ALARM(=2),闹钟开机\r\nrtos. POWERON_RESTART(=3),软件重启开机\r\nrtos. POWERON_EXCEPTION(=6),异常开机\r\nrtos. POWERON_HOST(=7),HOST 工具控制重启开机\r\nrtos. POWERON_WATCHDOG(=8),其他原因",
        "prefix": "rtos.poweron_reason()"
    },
    "rtos.receive()": {
        "body": "rtos.receive()",
        "description": "接收消息\r\n返回值：\r\n  如果 msg 为 table 类型，msg 根据不同的消息 msg.id 会有不同的数据：\r\n如果 msg 为 number 类型，msg 根据不同的消息 msg 会有不同的数据\r\n1.rtos.MSG_TIMER 定时器超时消息\r\nmsg.timer_id 或者 msgpara 为超时的定时器 id\r\n2.rtos.MSG_UART_RXDATA 串口 ATC 数据提醒\r\nmsg.uart_id 或者msgpara为收到的数据的串口id或者atc,收到该消息后可以通过uart.read\r\n接口读取数据\r\n3.rtos.MSG_KEYPAD 键盘消息,必须初始化按键(#rtos.init_module#)后才会有键盘消息\r\nmsg.pressed 按键按下/弹起\r\nmsg.key_matrix_row 按键所在行值\r\nmsg.key_matrix_col 按键所在列值\r\n4.rtos.WAIT_MSG_TIMEOUT 等待消息超时\r\n5.rtos.MSG_INT 中断消息\r\nmsg.int_id 中断 id\r\nmsg.int_resnum 中断 pin 脚编号\r\n6.rtos.MSG_PMD 电源管理消息\r\nmsg.present 电池在位状态\r\nmsg.level 百分比 0-100\r\nmsg.voltage 电池电压\r\nmsg.charger 充电器在位状态\r\nmsg.state 充电状态:0-不在充电 1-充电中 2-充电停止",
        "prefix": "rtos.receive()"
    },
    "rtos.remove_dir()": {
        "body": "rtos.remove_dir()",
        "description": "删除文件夹\r\n返回值：\r\n  true表示删除成功，false表示失败",
        "prefix": "rtos.remove_dir()"
    },
    "rtos.restart()": {
        "body": "rtos.restart()",
        "description": "软件重启\r\n返回值：\r\n  无",
        "prefix": "rtos.restart()"
    },
    "rtos.set_alarm()": {
        "body": "rtos.set_alarm()",
        "description": "设置闹钟，在设置之前必须注册闹钟模块和注册消息回调函数\r\n返回值：\r\n  无\r\n例子：\r\nrtos.init_module(rtos.MOD_ALARM) --注册闹铃模块\r\nsys.regmsg(rtos.MSG_ALARM,alarmmsg) --注册消息回调函数\r\nrtos.set_alarm(1, 2017, 12, 7, 10, 52, 0) --设置闹铃\r\n--闹钟时间 2017-17-7 10:52:0\r\nrtos.set_alarm(0, 0, 0, 0, 0, 0, 0)  --关闭闹铃\r\n\r\n--闹钟开机\r\nlocal reason = rtos.poweron_reason()\r\nif reason == rtos.POWERON_ALARM then\r\n\trtos.restart()-- 闹钟开机以后重启不然注册不上GSM协议栈\r\nend\r\n\r\n",
        "prefix": "rtos.set_alarm()"
    },
    "rtos.sleep()": {
        "body": "rtos.sleep()",
        "description": "延时函数\r\n返回值：\r\n  无",
        "prefix": "rtos.sleep()"
    },
    "rtos.tick()": {
        "body": "rtos.tick()",
        "description": "获取系统开机运行时间总计数\r\n返回值：\r\n  ticks，时间计数，每 tick 时长1/16384秒",
        "prefix": "rtos.tick()"
    },
    "rtos.timer_start()": {
        "body": "rtos.timer_start()",
        "description": "启动定时器\r\n返回值：\r\n  无",
        "prefix": "rtos.timer_start()"
    },
    "rtos.timer_stop()": {
        "body": "rtos.timer_stop()",
        "description": "停止定时器\r\n返回值：\r\n  无",
        "prefix": "rtos.timer_stop()"
    },
    "rtos.toint64()": {
        "body": "rtos.toint64()",
        "description": "将数字字符串转为int64类型数据\r\n返回值：\r\n  int64数据的二进制内容字符串",
        "prefix": "rtos.toint64()"
    },
    "scanCode.request(cbFnc, timeout)": {
        "body": "scanCode.request(${1:cbFnc},${2: timeout})",
        "description": "设置扫码请求\r\n返回值：\r\n无\r\n例子：\r\nscanCode.request(cbFnc)\r\nscanCode.request(cbFnc,5000)\r\n",
        "prefix": "scanCode.request(cbFnc, timeout)"
    },
    "select": {
        "body": "select(${1:index}, ${2:...})",
        "description": "select (index, ···)",
        "prefix": "select"
    },
    "setfenv": {
        "body": "setfenv(${0:...})",
        "description": "setfenv (f, table)",
        "prefix": "setfenv"
    },
    "setmetatable": {
        "body": "setmetatable(${1:table}, ${2:metatable})",
        "description": "setmetatable (table, metatable)",
        "prefix": "setmetatable"
    },
    "sim.getIccid()": {
        "body": "sim.getIccid()",
        "description": "获取sim卡的iccid\r\n返回值：\r\nstring ,返回iccid，如果还没有读取出来，则返回nil\r\n例子：\r\n-- 注意：开机lua脚本运行之后，会发送at命令去查询iccid，所以需要一定时间才能获取到iccid。开机后立即调用此接口，基本上返回nil\r\nsim.getIccid()\r\n",
        "prefix": "sim.getIccid()"
    },
    "sim.getImsi()": {
        "body": "sim.getImsi()",
        "description": "获取sim卡的imsi\r\n返回值：\r\nstring ,返回imsi，如果还没有读取出来，则返回nil\r\n例子：\r\n-- 开机lua脚本运行之后，会发送at命令去查询imsi，所以需要一定时间才能获取到imsi。开机后立即调用此接口，基本上返回nil\r\nsim.getImsi()\r\n",
        "prefix": "sim.getImsi()"
    },
    "sim.getMcc()": {
        "body": "sim.getMcc()",
        "description": "获取sim卡的mcc\r\n返回值：\r\nstring ,返回值：mcc，如果还没有读取出来，则返回\"\"\r\n例子：\r\n-- 注意：开机lua脚本运行之后，会发送at命令去查询imsi，所以需要一定时间才能获取到imsi。开机后立即调用此接口，基本上返回\"\"\r\nsim.getMcc()\r\n",
        "prefix": "sim.getMcc()"
    },
    "sim.getMnc()": {
        "body": "sim.getMnc()",
        "description": "获取sim卡的getmnc\r\n返回值：\r\nstring ,返回mnc，如果还没有读取出来，则返回\"\"\r\n例子：\r\n-- 注意：开机lua脚本运行之后，会发送at命令去查询imsi，所以需要一定时间才能获取到imsi。开机后立即调用此接口，基本上返回\"\"\r\nsim.getMnc()\r\n",
        "prefix": "sim.getMnc()"
    },
    "sim.getNumber()": {
        "body": "sim.getNumber()",
        "description": "获取sim卡的本机号码\r\n返回值：\r\nstring ,返回值：sNumber，如果还没有读取出来或者读取失败，则返回\"\"\r\n例子：\r\n-- 注意：开机lua脚本运行之后，会发送at命令去查询本机号码，所以需要一定时间才能获取到本机号码。开机后立即调用此接口，基本上返回\"\"\r\n-- 注意：此功能需要卡商支持，卡商必须把卡写到sim卡中，模块才能从卡中读出号码；目前市场上的很多卡，没有写入号码，是无法读取得\r\nsim.getMcc()\r\n",
        "prefix": "sim.getNumber()"
    },
    "sim.getStatus()": {
        "body": "sim.getStatus()",
        "description": "获取sim卡的状态\r\n返回值：\r\nbool ,true表示sim卡正常，false或者nil表示未检测到卡或者卡异常\r\n例子：\r\n-- 开机lua脚本运行之后，会发送at命令去查询状态，所以需要一定时间才能获取到状态。开机后立即调用此接口，基本上返回nil\r\nsim.getStatus()\r\n",
        "prefix": "sim.getStatus()"
    },
    "sim.getType()": {
        "body": "sim.getType()",
        "description": "获取sim卡类型\r\n返回值：\r\nstring ,\"UNSUPPORT\"表示core软件不支持此功能，\"NO_RDY_SIM\"表示SIM卡未就绪；\"VSIM\"表示虚拟SIM卡，\"REAL_SIM\"表示实体SIM卡\r\n例子：\r\nsim.getType()\r\n",
        "prefix": "sim.getType()"
    },
    "sim.setQueryNumber(flag)": {
        "body": "sim.setQueryNumber(${1:flag})",
        "description": "设置“是否打开查询本机号码”的功能\r\n返回值：\r\nnil\r\n例子：\r\nsim.setQueryNumber(true)\r\n",
        "prefix": "sim.setQueryNumber(flag)"
    },
    "sms.send(num, data, cbFnc, idx)": {
        "body": "sms.send(${1:num},${2: data},${3: cbFnc},${4: idx})",
        "description": "发送短信\r\n返回值：\r\nresult，true表示调用接口成功（并不是短信发送成功，短信发送结果，通过sendcnf返回，如果有cbFnc，会通知cbFnc函数）；返回false，表示调用接口失败\r\n例子：\r\nsms.send(\"10086\",\"test\",cbFnc)\r\n",
        "prefix": "sms.send(num, data, cbFnc, idx)"
    },
    "sms.setNewSmsCb(cbFnc)": {
        "body": "sms.setNewSmsCb(${1:cbFnc})",
        "description": "设置新短信的用户处理函数\r\n返回值：\r\nnil\r\n例子：\r\nsms.setNewSmsCb(cbFnc)\r\n",
        "prefix": "sms.setNewSmsCb(cbFnc)"
    },
    "socket.isReady()": {
        "body": "socket.isReady()",
        "description": "SOCKET 是否有可用\r\n返回值：\r\n可用true,不可用false",
        "prefix": "socket.isReady()"
    },
    "socket.setDnsParser(parserFnc)": {
        "body": "socket.setDnsParser(${1:parserFnc})",
        "description": "设置用户自定义的DNS解析器.\r\n返回值：\r\nnil\r\n例子：\r\nsocket.setDnsParser(parserFnc)\r\n",
        "prefix": "socket.setDnsParser(parserFnc)"
    },
    "socket.setSendMode(mode)": {
        "body": "socket.setSendMode(${1:mode})",
        "description": "设置数据发送模式（在网络准备就绪之前调用此接口设置）.\r\n返回值：\r\nnil\r\n例子：\r\nsocket.setSendMode(1)\r\n",
        "prefix": "socket.setSendMode(mode)"
    },
    "socket.setTcpResendPara(retryCnt, retryMaxTimeout)": {
        "body": "socket.setTcpResendPara(${1:retryCnt},${2: retryMaxTimeout})",
        "description": "设置TCP层自动重传的参数\r\n返回值：\r\nnil\r\n例子：\r\nsetTcpResendPara(3,8)\r\nsetTcpResendPara(4,16)\r\n",
        "prefix": "socket.setTcpResendPara(retryCnt, retryMaxTimeout)"
    },
    "socket.tcp(ssl, cert)": {
        "body": "socket.tcp(${1:ssl},${2: cert})",
        "description": "创建基于TCP的socket对象\r\n返回值：\r\nclient，创建成功返回socket客户端对象；创建失败返回nil\r\n例子：\r\nc = socket.tcp()\r\nc = socket.tcp(true)\r\nc = socket.tcp(true, {caCert=\"ca.crt\"})\r\nc = socket.tcp(true, {caCert=\"ca.crt\", clientCert=\"client.crt\", clientKey=\"client.key\"})\r\nc = socket.tcp(true, {caCert=\"ca.crt\", clientCert=\"client.crt\", clientKey=\"client.key\", clientPassword=\"123456\"})\r\n",
        "prefix": "socket.tcp(ssl, cert)"
    },
    "socket.udp()": {
        "body": "socket.udp()",
        "description": "创建基于UDP的socket对象\r\n返回值：\r\nclient，创建成功返回socket客户端对象；创建失败返回nil\r\n例子：\r\nc = socket.udp()\r\n",
        "prefix": "socket.udp()"
    },
    "spi.close()": {
        "body": "spi.close()",
        "description": "关闭SPI\r\n返回值：\r\n  number类型，1表示成功，0表示失败",
        "prefix": "spi.close()"
    },
    "spi.recv()": {
        "body": "spi.recv()",
        "description": "读数据\r\n返回值：\r\n  string类型，读取的数据内容",
        "prefix": "spi.recv()"
    },
    "spi.send()": {
        "body": "spi.send()",
        "description": "写数据\r\n返回值：\r\n  number类型，写成功的数据长度",
        "prefix": "spi.send()"
    },
    "spi.send_recv()": {
        "body": "spi.send_recv()",
        "description": "读写数据\r\n返回值：\r\n  string类型，读取的数据内容",
        "prefix": "spi.send_recv()"
    },
    "spi.setup": {
        "body": "spi.setup",
        "description": "- 语法\r\n返回值：\r\n  number类型，1表示成功，0表示失败",
        "prefix": "spi.setup"
    },
    "string.byte()": {
        "body": "string.byte()",
        "description": "接收控制字符，返回ASCII码\r\n返回值：\r\n  ASCII码\r\n例子：\r\nstring.byte(\"ABCD\")  --65\r\nstring.byte(\"ABCD\",4) --68\r\n",
        "prefix": "string.byte()"
    },
    "string.char()": {
        "body": "string.char()",
        "description": "接收ASCII码，返回对应的控制字符\r\n返回值：\r\n  字符\r\n例子：\r\nstring.char(97,98,99,100)   --abcd\r\n",
        "prefix": "string.char()"
    },
    "string.find()": {
        "body": "string.find()",
        "description": "查找第一个字符串 s 中匹配到的 pattern\r\n返回值：\r\n  返回匹配字符具体位置。不存在则返回 nil\r\n例子：\r\nstring.find(\"Hello Lua user\", \"Lua\", 1)   --7   9\r\n",
        "prefix": "string.find()"
    },
    "string.format()": {
        "body": "string.format()",
        "description": "格式化字符串\r\n返回值：\r\n  字符串\r\n例子：\r\nstring.format(\"the value is:%d\",4)   --the value is:4\r\n",
        "prefix": "string.format()"
    },
    "string.formatNumberThousands(num)": {
        "body": "string.formatNumberThousands(${1:num})",
        "description": "返回数字的千位符号格式\r\n返回值：\r\nstring，千位符号的数字字符串\r\n例子：\r\nloca s = string.formatNumberThousands(1000) ,s = \"1,000\"\r\n",
        "prefix": "string.formatNumberThousands(num)"
    },
    "string.fromHex(hex)": {
        "body": "string.fromHex(${1:hex})",
        "description": "将HEX字符串转成Lua字符串，如\"313233616263\"转为\"123abc\", 函数里加入了过滤分隔符，可以过滤掉大部分分隔符（可参见正则表达式中\\s和\\p的范围）。\r\n返回值：\r\ncharstring,字符组成的串\r\n例子：\r\nstring.fromHex(\"010203\")       ->  \"\\1\\2\\3\"\r\nstring.fromHex(\"313233616263\") ->  \"123abc\"\r\n",
        "prefix": "string.fromHex(hex)"
    },
    "string.gsub()": {
        "body": "string.gsub()",
        "description": "字符串替换",
        "prefix": "string.gsub()"
    },
    "string.len()": {
        "body": "string.len()",
        "description": "计算字符串长度\r\n返回值：\r\n  字符串长度\r\n例子：\r\nstring.len(\"abc\")  --3\r\n",
        "prefix": "string.len()"
    },
    "string.lower()": {
        "body": "string.lower()",
        "description": "字符串全部转为小写字母\r\n返回值：\r\n  小写字母字符串",
        "prefix": "string.lower()"
    },
    "string.rawurlEncode(str)": {
        "body": "string.rawurlEncode(${1:str})",
        "description": "返回字符串的 RFC3986 编码\r\n返回值：\r\nstr, RFC3986 编码的字符串\r\n例子：\r\nlocal str = string.rawurlEncode(\"####133\") ,str == \"%23%23%23%23133\"\r\nlocal str = string.rawurlEncode(\"中国2018\") , str == \"%e4%b8%ad%e5%9b%bd2018\"\r\n",
        "prefix": "string.rawurlEncode(str)"
    },
    "string.rep()": {
        "body": "string.rep()",
        "description": "字符串拷贝\r\n返回值：\r\n  字符串\r\n例子：\r\nstring.rep(\"abcd\",2)   --abcdabcd\r\n",
        "prefix": "string.rep()"
    },
    "string.reverse()": {
        "body": "string.reverse()",
        "description": "字符串反转\r\n返回值：\r\n  反转后的字符串\r\n例子：\r\nstring.reverse(\"Luat\")  --tauL\r\n",
        "prefix": "string.reverse()"
    },
    "string.split(str, delimiter)": {
        "body": "string.split(${1:str},${2: delimiter})",
        "description": "按照指定分隔符分割字符串\r\n返回值：\r\n分割后的字符串列表\r\n例子：\r\n\"123,456,789\":split(',') -> {'123','456','789'}\r\n",
        "prefix": "string.split(str, delimiter)"
    },
    "string.toHex(str, separator)": {
        "body": "string.toHex(${1:str},${2: separator})",
        "description": "将Lua字符串转成HEX字符串，如\"123abc\"转为\"313233616263\"\r\n返回值：\r\nhexstring 16进制组成的串\r\n例子：\r\nstring.toHex(\"\\1\\2\\3\") -> \"010203\" 3\r\nstring.toHex(\"123abc\") -> \"313233616263\" 6\r\nstring.toHex(\"123abc\",\" \") -> \"31 32 33 61 62 63 \" 6\r\n",
        "prefix": "string.toHex(str, separator)"
    },
    "string.toValue(str)": {
        "body": "string.toValue(${1:str})",
        "description": "返回字符串tonumber的转义字符串(用来支持超过31位整数的转换)\r\n返回值：\r\nstr 转换后的lua 二进制字符串\r\n例子：\r\nstring.toValue(\"123456\") -> \"\\1\\2\\3\\4\\5\\6\"  6\r\nstring.toValue(\"123abc\") -> \"\\1\\2\\3\\a\\b\\c\"  6\r\n",
        "prefix": "string.toValue(str)"
    },
    "string.upper()": {
        "body": "string.upper()",
        "description": "字符串全部转为大写字母\r\n返回值：\r\n  大写字母字符串",
        "prefix": "string.upper()"
    },
    "string.urlEncode(str)": {
        "body": "string.urlEncode(${1:str})",
        "description": "返回字符串的urlEncode编码\r\n返回值：\r\nstr,urlEncode编码的字符串\r\n例子：\r\nlocal str = string.urlEncode(\"####133\") ,str == \"%23%23%23%23133\"\r\nlocal str = string.urlEncode(\"中国2018\") , str == \"%e4%b8%ad%e5%9b%bd2018\"\r\n",
        "prefix": "string.urlEncode(str)"
    },
    "string.utf8Len(str)": {
        "body": "string.utf8Len(${1:str})",
        "description": "返回utf8编码字符串的长度\r\n返回值：\r\nnumber,返回字符串长度\r\n例子：\r\nlocal cnt = string.utf8Len(\"中国a\"),cnt == 3\r\n",
        "prefix": "string.utf8Len(str)"
    },
    "string.utf8ToTable(str)": {
        "body": "string.utf8ToTable(${1:str})",
        "description": "返回utf8编码字符串的单个utf8字符的table\r\n返回值：\r\ntable,utf8字符串的table\r\n例子：\r\nlocal t = string.utf8ToTable(\"中国2018\")\r\n",
        "prefix": "string.utf8ToTable(str)"
    },
    "sys.init(mode, lprfnc)": {
        "body": "sys.init(${1:mode},${2: lprfnc})",
        "description": "Luat平台初始化\r\n返回值：\r\n无\r\n例子：\r\nsys.init(1,0)\r\n",
        "prefix": "sys.init(mode, lprfnc)"
    },
    "sys.publish(...)": {
        "body": "sys.publish(${1:...})",
        "description": "发布内部消息，存储在内部消息队列中\r\n返回值：\r\n无\r\n例子：\r\npublish(\"NET_STATUS_IND\")\r\n",
        "prefix": "sys.publish(...)"
    },
    "sys.restart(r)": {
        "body": "sys.restart(${1:r})",
        "description": "软件重启\r\n返回值：\r\n无\r\n例子：\r\nsys.restart('程序超时软件重启')\r\n",
        "prefix": "sys.restart(r)"
    },
    "sys.run()": {
        "body": "sys.run()",
        "description": "run()从底层获取core消息并及时处理相关消息，查询定时器并调度各注册成功的任务线程运行和挂起\r\n返回值：\r\n无\r\n例子：\r\nsys.run()\r\n",
        "prefix": "sys.run()"
    },
    "sys.setRollBack(flag, secs)": {
        "body": "sys.setRollBack(${1:flag},${2: secs})",
        "description": "设置“lua脚本运行出错时，是否回退原始烧写版本”的功能开关。如果没有调用此接口设置，默认回滚\r\n返回值：\r\nnil\r\n例子：\r\nsys.setRollBack(true)\r\nsys.setRollBack(false)\r\n",
        "prefix": "sys.setRollBack(flag, secs)"
    },
    "sys.subscribe(id, callback)": {
        "body": "sys.subscribe(${1:id},${2: callback})",
        "description": "订阅消息\r\n返回值：\r\n无\r\n例子：\r\nsubscribe(\"NET_STATUS_IND\", callback)\r\n",
        "prefix": "sys.subscribe(id, callback)"
    },
    "sys.taskInit(fun, ...)": {
        "body": "sys.taskInit(${1:fun},${2: ...})",
        "description": "创建一个任务线程,在模块最末行调用该函数并注册模块中的任务函数，main.lua导入该模块即可\r\n返回值：\r\nco  返回该任务的线程号\r\n例子：\r\nsys.taskInit(task1,'a','b')\r\n",
        "prefix": "sys.taskInit(fun, ...)"
    },
    "sys.timerIsActive(val, ...)": {
        "body": "sys.timerIsActive(${1:val},${2: ...})",
        "description": "判断某个定时器是否处于开启状态\r\n返回值：\r\nnumber 开启状态返回true，否则nil",
        "prefix": "sys.timerIsActive(val, ...)"
    },
    "sys.timerLoopStart(fnc, ms, ...)": {
        "body": "sys.timerLoopStart(${1:fnc},${2: ms},${3: ...})",
        "description": "开启一个循环定时器\r\n返回值：\r\nnumber 定时器ID，如果失败，返回nil",
        "prefix": "sys.timerLoopStart(fnc, ms, ...)"
    },
    "sys.timerStart(fnc, ms, ...)": {
        "body": "sys.timerStart(${1:fnc},${2: ms},${3: ...})",
        "description": "开启一个定时器\r\n返回值：\r\nnumber 定时器ID，如果失败，返回nil",
        "prefix": "sys.timerStart(fnc, ms, ...)"
    },
    "sys.timerStop(val, ...)": {
        "body": "sys.timerStop(${1:val},${2: ...})",
        "description": "关闭定时器\r\n返回值：\r\n无\r\n例子：\r\ntimerStop(1)\r\n",
        "prefix": "sys.timerStop(val, ...)"
    },
    "sys.timerStopAll(fnc)": {
        "body": "sys.timerStopAll(${1:fnc})",
        "description": "关闭同一回调函数的所有定时器\r\n返回值：\r\n无\r\n例子：\r\ntimerStopAll(cbFnc)\r\n",
        "prefix": "sys.timerStopAll(fnc)"
    },
    "sys.unsubscribe(id, callback)": {
        "body": "sys.unsubscribe(${1:id},${2: callback})",
        "description": "取消订阅消息\r\n返回值：\r\n无\r\n例子：\r\nunsubscribe(\"NET_STATUS_IND\", callback)\r\n",
        "prefix": "sys.unsubscribe(id, callback)"
    },
    "sys.wait(ms)": {
        "body": "sys.wait(${1:ms})",
        "description": "Task任务延时函数，只能用于任务函数中\r\n返回值：\r\n定时结束返回nil,被其他线程唤起返回调用线程传入的参数\r\n例子：\r\nsys.wait(30)\r\n",
        "prefix": "sys.wait(ms)"
    },
    "sys.waitUntil(id, ms)": {
        "body": "sys.waitUntil(${1:id},${2: ms})",
        "description": "Task任务的条件等待函数（包括事件消息和定时器消息等条件），只能用于任务函数中。\r\n返回值：\r\nresult 接收到消息返回true，超时返回false\r\n例子：\r\nresult, data = sys.waitUntil(\"SIM_IND\", 120000)\r\n",
        "prefix": "sys.waitUntil(id, ms)"
    },
    "sys.waitUntilExt(id, ms)": {
        "body": "sys.waitUntilExt(${1:id},${2: ms})",
        "description": "Task任务的条件等待函数扩展（包括事件消息和定时器消息等条件），只能用于任务函数中。\r\n返回值：\r\nmessage 接收到消息返回message，超时返回false\r\n例子：\r\nresult, data = sys.waitUntilExt(\"SIM_IND\", 120000)\r\n",
        "prefix": "sys.waitUntilExt(id, ms)"
    },
    "table.concat()": {
        "body": "table.concat()",
        "description": "表连接\r\n返回值：\r\n  字符串\r\n例子：\r\nfruits = {\"banana\",\"orange\",\"apple\"}\r\n-- 返回 table 连接后的字符串\r\nprint(\"连接后的字符串 \",table.concat(fruits))\r\n--连接后的字符串     bananaorangeapple\r\n\r\n-- 指定连接字符\r\nprint(\"连接后的字符串 \",table.concat(fruits,\", \"))\r\n--连接后的字符串     banana, orange, apple\r\n\r\n-- 指定索引来连接 table\r\nprint(\"连接后的字符串 \",table.concat(fruits,\", \", 2,3))\r\n--连接后的字符串     orange, apple\r\n",
        "prefix": "table.concat()"
    },
    "table.gsort(t, f)": {
        "body": "table.gsort(${1:t},${2: f})",
        "description": "返回一个迭代器函数,每次调用函数都会返回hash表的排序后的键值对\r\n返回值：\r\nfunction.\r\n例子：\r\ntest = {a=1,f=9,d=2,c=8,b=5}\r\nfor name,line in pairsByKeys(test) do print(name,line) end\r\n",
        "prefix": "table.gsort(t, f)"
    },
    "table.insert()": {
        "body": "table.insert()",
        "description": "添加table参数\r\n返回值：\r\n  table\r\n例子：\r\nfruits = {\"banana\",\"orange\",\"apple\"}\r\n\r\n-- 在末尾插入\r\ntable.insert(fruits,\"mango\")\r\nprint(\"索引为 4 的元素为 \",fruits[4])\r\n--索引为 4 的元素为     mango\r\n\r\n-- 在索引为 2 的键处插入\r\ntable.insert(fruits,2,\"grapes\")\r\nprint(\"索引为 2 的元素为 \",fruits[2])\r\n--索引为 2 的元素为     grapes\r\n\r\nprint(\"最后一个元素为 \",fruits[5])\r\n--最后一个元素为     mango\r\n",
        "prefix": "table.insert()"
    },
    "table.rconcat(l)": {
        "body": "table.rconcat(${1:l})",
        "description": "table.concat的增强版，支持嵌套字符串数组\r\n返回值：\r\nstring\r\n例子：\r\nprint(table.rconcat({\"a\",{\" nice \"},\" and \", {{\" long \"},{\" list \"}}}))\r\n",
        "prefix": "table.rconcat(l)"
    },
    "table.remove()": {
        "body": "table.remove (table [, pos])",
        "description": "移除table参数\r\n返回值：\r\n  table",
        "prefix": "table.remove()"
    },
    "tonumber": {
        "body": "tonumber(${1:e}${2:[, base]})",
        "description": "tonumber (e [, base])",
        "prefix": "tonumber"
    },
    "tostring": {
        "body": "tostring(${1:v})",
        "description": "tostring (v)",
        "prefix": "tostring"
    },
    "type": {
        "body": "type(${1:v})",
        "description": "type (v)",
        "prefix": "type"
    },
    "uart.close()": {
        "body": "uart.close()",
        "description": "关闭 uart 接口\r\n返回值：\r\n  无",
        "prefix": "uart.close()"
    },
    "uart.getchar()": {
        "body": "uart.getchar()",
        "description": "从串口读取单字符\r\n返回值：\r\n  串口读出来的字符",
        "prefix": "uart.getchar()"
    },
    "uart.on (id, event, callback)": {
        "body": "uart.on (${1:id},${2: event},${3: callback})",
        "description": "注册串口事件的处理函数\r\n返回值：\r\nnil\r\n例子：\r\nuart.on(1,\"receive\",rcvFnc)\r\nuart.on(1,\"sent\",sentFnc)\r\n",
        "prefix": "uart.on (id, event, callback)"
    },
    "uart.read()": {
        "body": "uart.read()",
        "description": "从串口读取字符串\r\n返回值：\r\n  串口读出到的数据",
        "prefix": "uart.read()"
    },
    "uart.set_rs485_oe()": {
        "body": "uart.set_rs485_oe()",
        "description": "* 语法\r\n返回值：\r\n    无\r\n例子：\r\nuart.setup(UART_ID,115200,8,uart.PAR_NONE,uart.STOP_1,nil,1) --必须先使用setup，并且最后一个参数是1（打开发送完成后的通知功能）\r\nuart.set_rs485_oe(UART_ID, pio.P2_0) --仅4G 0013版本之后支持\r\n\r\n",
        "prefix": "uart.set_rs485_oe()"
    },
    "uart.setup()": {
        "body": "uart.setup()",
        "description": "uart通讯\r\n返回值：\r\n  串口的真实波特率",
        "prefix": "uart.setup()"
    },
    "uart.write()": {
        "body": "uart.write()",
        "description": "向串口写字符串或者整型数据\r\n返回值：\r\n  无",
        "prefix": "uart.write()"
    },
    "uiWin.add(wnd)": {
        "body": "uiWin.add(${1:wnd})",
        "description": "新增一个窗口\r\n返回值：\r\nnumber，窗口ID\r\n例子：\r\nuiWin.add({onUpdate = refresh})\r\n",
        "prefix": "uiWin.add(wnd)"
    },
    "uiWin.isActive(winId)": {
        "body": "uiWin.isActive(${1:winId})",
        "description": "判断一个窗口是否处于最前显示\r\n返回值：\r\nbool，true表示最前显示，其余表示非最前显示\r\n例子：\r\nuiWin.isActive(winId)\r\n",
        "prefix": "uiWin.isActive(winId)"
    },
    "uiWin.remove(winId)": {
        "body": "uiWin.remove(${1:winId})",
        "description": "移除一个窗口\r\n返回值：\r\nnil\r\n例子：\r\nuiWin.remove(winId)\r\n",
        "prefix": "uiWin.remove(winId)"
    },
    "unpack": {
        "body": "unpack(${0:...})",
        "description": "unpack (list [, i [, j]])",
        "prefix": "unpack"
    },
    "update.request(cbFnc, url, period, redir)": {
        "body": "update.request(${1:cbFnc},${2: url},${3: period},${4: redir})",
        "description": "启动远程升级功能\r\n返回值：\r\nnil\r\n例子：\r\nupdate.request()\r\nupdate.request(cbFnc)\r\nupdate.request(cbFnc,\"www.userserver.com/update\")\r\nupdate.request(cbFnc,nil,4*3600*1000)\r\nupdate.request(cbFnc,nil,4*3600*1000,true)\r\n",
        "prefix": "update.request(cbFnc, url, period, redir)"
    },
    "wdt.restart(rst, wd)": {
        "body": "wdt.restart(${1:rst},${2: wd})",
        "description": "硬件看门狗立即重启模块\r\n返回值：\r\nnil\r\n例子：\r\nwdt.restart()\r\n",
        "prefix": "wdt.restart(rst, wd)"
    },
    "wdt.setup(rst, wd)": {
        "body": "wdt.setup(${1:rst},${2: wd})",
        "description": "配置模块与看门狗通讯IO并启动任务\r\n返回值：\r\n无\r\n例子：\r\nsetup(pio.P0_31,pio.P0_29)\r\n",
        "prefix": "wdt.setup(rst, wd)"
    },
    "xpcall": {
        "body": "xpcall(${0:...})",
        "description": "xpcall (f, err)",
        "prefix": "xpcall"
    }
}